{"meta":{"title":"Cong's Blog","subtitle":"不喜正式的交谈","description":"To be a better me~","author":"钱聪","url":"http://www.congboss.top"},"pages":[{"title":"关于我","date":"2017-04-10T14:29:18.000Z","updated":"2019-05-12T09:12:20.846Z","comments":true,"path":"about/index.html","permalink":"http://www.congboss.top/about/index.html","excerpt":"","text":"南京码农一枚，安安静静学习和生活~大学本科与硕士均在南京邮电大学度过，专业为计算机科学与技术。写过前端，后台做过，Android也玩过，现在主要从事后台开发，并且对新技术充满热情。喜欢熊本部长，喜欢萌宠，喜欢爬山~声明：本博客文章只是为了记录个人学习和生活上总结，笔记向~&gt; 邮箱: congqian62@126.com&gt; QQ: 1227388900&gt; 微信: Congboss62&gt; 知乎: https://www.zhihu.com/people/qian-cong-70/activities&gt; Github: https://github.com/Congboss","raw":null,"content":null},{"title":"分类","date":"2017-04-11T02:17:46.000Z","updated":"2017-11-14T02:54:47.391Z","comments":false,"path":"categories/index.html","permalink":"http://www.congboss.top/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"","date":"2017-11-14T02:35:48.000Z","updated":"2017-11-14T02:39:05.561Z","comments":true,"path":"guestbook/index.html","permalink":"http://www.congboss.top/guestbook/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"","date":"2017-11-13T11:39:47.000Z","updated":"2018-04-15T05:23:33.539Z","comments":true,"path":"photos/index.html","permalink":"http://www.congboss.top/photos/index.html","excerpt":"","text":"生活中随手拍的图片，还有一些是自己喜欢的图片。 与大家分享，不是专业摄影师，不喜勿喷，emmmmmm~ 所有图片转载需要经过本人同意 三亚 雪 ~","raw":null,"content":null},{"title":"标签","date":"2017-04-11T02:19:26.000Z","updated":"2017-11-14T02:51:42.671Z","comments":false,"path":"tags/index.html","permalink":"http://www.congboss.top/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"浅谈红黑树","slug":"红黑树","date":"2018-06-17T11:00:42.000Z","updated":"2018-08-02T13:10:43.790Z","comments":true,"path":"2018/06/17/红黑树/","link":"","permalink":"http://www.congboss.top/2018/06/17/红黑树/","excerpt":" 红黑树，满足二分搜索树的性质，与AVL一样，在二分搜索树的基础上，添加了一些特性保证自己不会退化为链表，也就是保证自己是一棵平衡二叉树。\n红黑树具有以下五个性质：\n每个节点或者是红色的，或者是黑色的\n根节点是黑色的\n每个叶子结点（最后的空节点）是黑色的\n如果一个节点是红色的，那么他的孩子节点都是黑色的\n从任意一个节点到叶子节点，经过的黑色节点是一样的\n","text":"红黑树，满足二分搜索树的性质，与AVL一样，在二分搜索树的基础上，添加了一些特性保证自己不会退化为链表，也就是保证自己是一棵平衡二叉树。 红黑树具有以下五个性质： 每个节点或者是红色的，或者是黑色的 根节点是黑色的 每个叶子结点（最后的空节点）是黑色的 如果一个节点是红色的，那么他的孩子节点都是黑色的 从任意一个节点到叶子节点，经过的黑色节点是一样的 在具体讲红黑树之前，我们来谈谈另一种平衡的树结构：2-3树。 事实上，红黑树与2-3树是等价的。 2-3树： 满足二分搜索树的基本性质 节点可以存放一个元素或者两个元素 每个节点或者有两个孩子或者有三个孩子 2-3是一颗绝对平衡的树 可以通过下图来理解上述的性质： 图解2-3树保持绝对平衡的原理： 而红黑树的发明人Rudolf Bayer在算法四这本书说明了红黑树与2-3树的等价性： 向红黑树中添加元素： 实现红黑树的相关业务逻辑：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259import java.util.ArrayList;public class RBTree&lt;K extends Comparable&lt;K&gt;, V&gt; &#123; private static final boolean RED = true; private static final boolean BLACK = false; private class Node&#123; public K key; public V value; public Node left, right; public boolean color; public Node(K key, V value)&#123; this.key = key; this.value = value; left = null; right = null; color = RED; &#125; &#125; private Node root; private int size; public RBTree()&#123; root = null; size = 0; &#125; public int getSize()&#123; return size; &#125; public boolean isEmpty()&#123; return size == 0; &#125; // 判断节点node的颜色 private boolean isRed(Node node)&#123; if(node == null) return BLACK; return node.color; &#125; // node x // / \\ 左旋转 / \\ // T1 x ---------&gt; node T3 // / \\ / \\ // T2 T3 T1 T2 private Node leftRotate(Node node)&#123; Node x = node.right; // 左旋转 node.right = x.left; x.left = node; x.color = node.color; node.color = RED; return x; &#125; // node x // / \\ 右旋转 / \\ // x T2 -------&gt; y node // / \\ / \\ // y T1 T1 T2 private Node rightRotate(Node node)&#123; Node x = node.left; // 右旋转 node.left = x.right; x.right = node; x.color = node.color; node.color = RED; return x; &#125; // 颜色翻转 private void flipColors(Node node)&#123; node.color = RED; node.left.color = BLACK; node.right.color = BLACK; &#125; // 向红黑树中添加新的元素(key, value) public void add(K key, V value)&#123; root = add(root, key, value); root.color = BLACK; // 最终根节点为黑色节点 &#125; // 向以node为根的红黑树中插入元素(key, value)，递归算法 // 返回插入新节点后红黑树的根 private Node add(Node node, K key, V value)&#123; if(node == null)&#123; size ++; return new Node(key, value); // 默认插入红色节点 &#125; if(key.compareTo(node.key) &lt; 0) node.left = add(node.left, key, value); else if(key.compareTo(node.key) &gt; 0) node.right = add(node.right, key, value); else // key.compareTo(node.key) == 0 node.value = value; if (isRed(node.right) &amp;&amp; !isRed(node.left)) node = leftRotate(node); if (isRed(node.left) &amp;&amp; isRed(node.left.left)) node = rightRotate(node); if (isRed(node.left) &amp;&amp; isRed(node.right)) flipColors(node); return node; &#125; // 返回以node为根节点的二分搜索树中，key所在的节点 private Node getNode(Node node, K key)&#123; if(node == null) return null; if(key.equals(node.key)) return node; else if(key.compareTo(node.key) &lt; 0) return getNode(node.left, key); else // if(key.compareTo(node.key) &gt; 0) return getNode(node.right, key); &#125; public boolean contains(K key)&#123; return getNode(root, key) != null; &#125; public V get(K key)&#123; Node node = getNode(root, key); return node == null ? null : node.value; &#125; public void set(K key, V newValue)&#123; Node node = getNode(root, key); if(node == null) throw new IllegalArgumentException(key + \" doesn't exist!\"); node.value = newValue; &#125; // 返回以node为根的二分搜索树的最小值所在的节点 private Node minimum(Node node)&#123; if(node.left == null) return node; return minimum(node.left); &#125; // 删除掉以node为根的二分搜索树中的最小节点 // 返回删除节点后新的二分搜索树的根 private Node removeMin(Node node)&#123; if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; node.left = removeMin(node.left); return node; &#125; // 从二分搜索树中删除键为key的节点 public V remove(K key)&#123; Node node = getNode(root, key); if(node != null)&#123; root = remove(root, key); return node.value; &#125; return null; &#125; private Node remove(Node node, K key)&#123; if( node == null ) return null; if( key.compareTo(node.key) &lt; 0 )&#123; node.left = remove(node.left , key); return node; &#125; else if(key.compareTo(node.key) &gt; 0 )&#123; node.right = remove(node.right, key); return node; &#125; else&#123; // key.compareTo(node.key) == 0 // 待删除节点左子树为空的情况 if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; // 待删除节点右子树为空的情况 if(node.right == null)&#123; Node leftNode = node.left; node.left = null; size --; return leftNode; &#125; // 待删除节点左右子树均不为空的情况 // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = removeMin(node.right); successor.left = node.left; node.left = node.right = null; return successor; &#125; &#125; public static void main(String[] args)&#123; System.out.println(\"Pride and Prejudice\"); ArrayList&lt;String&gt; words = new ArrayList&lt;&gt;(); if(FileOperation.readFile(\"pride-and-prejudice.txt\", words)) &#123; System.out.println(\"Total words: \" + words.size()); RBTree&lt;String, Integer&gt; map = new RBTree&lt;&gt;(); for (String word : words) &#123; if (map.contains(word)) map.set(word, map.get(word) + 1); else map.add(word, 1); &#125; System.out.println(\"Total different words: \" + map.getSize()); System.out.println(\"Frequency of PRIDE: \" + map.get(\"pride\")); System.out.println(\"Frequency of PREJUDICE: \" + map.get(\"prejudice\")); &#125; System.out.println(); &#125;&#125;","raw":null,"content":null,"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.congboss.top/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.congboss.top/tags/数据结构/"}]},{"title":"分布式session","slug":"分布式session","date":"2018-05-15T03:00:42.000Z","updated":"2018-06-17T16:03:55.409Z","comments":true,"path":"2018/05/15/分布式session/","link":"","permalink":"http://www.congboss.top/2018/05/15/分布式session/","excerpt":"登录与登出是非常普遍的功能，传统的后台管理系统会在初始化时在数据库中插入超级管理员的初始用户名和密码，后续再由超级管理员添加普通管理员并设置他们的密码。再然后普通管理人员在登录界面输入用户名和密码完成登录。    微信扫码登录时查询openid并与数据库中有权限的openid比较，如果比对成功，就放行。\n登录：验证身份，存储信息登出：失效浏览信息\n什么是分布式系统？旨在支持应用程序和服务的开发，可以利用物理架构由多个自制的处理元素，不共享主内存，但通过网络发送消息合作。                                             ——Leslie Lamport这是微软的科学家Leslie Lamport所给出的定义，他本人也是2013年的图灵奖的获得者，具备一定的权威性。","text":"登录与登出是非常普遍的功能，传统的后台管理系统会在初始化时在数据库中插入超级管理员的初始用户名和密码，后续再由超级管理员添加普通管理员并设置他们的密码。再然后普通管理人员在登录界面输入用户名和密码完成登录。 微信扫码登录时查询openid并与数据库中有权限的openid比较，如果比对成功，就放行。 登录：验证身份，存储信息登出：失效浏览信息 什么是分布式系统？旨在支持应用程序和服务的开发，可以利用物理架构由多个自制的处理元素，不共享主内存，但通过网络发送消息合作。 ——Leslie Lamport这是微软的科学家Leslie Lamport所给出的定义，他本人也是2013年的图灵奖的获得者，具备一定的权威性。 分布式系统的三个特点： 多节点 消息通信 不共享内存 三个概念： 分布式系统 集群 分布式计算 分布式系统与集群的异同：举个栗子：两个厨子在厨房做爱做的事情（当然是做菜啦），A厨子洗菜，B厨子烧菜：这种就是分布式；而如果两个都是在炒菜或者烧菜，那么就是集群。 而比如放到点餐系统中，卖家端与买家端是分布式的，如果其中一端相同的程序部署在许多服务器上，那么就称为集群。 分布式计算也称为并行计算，比如Hadoop中的Mapreduce就是并行计算。再拿厨子举例，两个厨子炒菜放在一个盘子里，就分不清菜到底是谁炒的。 综上，总结一下分布式系统与集群的区别与联系： 区别与联系：分布式系统强调的是不同的功能模块的节点，而集群指的是相同业务功能的节点。分布式系统中的每一个节点都可以做集群，集群的规模由节点的业务规模决定，而集群则并不一定是分布式的，比如All in one模式开发的系统。 Session狭义的session表达的是HttpSession，是一个J2EE接口。广义的session:即会话控制，众所周知，http协议是无状态的，对于同一个url请求并没有上下文关系，当用户完成登录之后需要有一个机制能够保存住用户的信息和状态，在后续的请求中能够验证用户的身份和检查用户的信息，这个依赖，就是会话控制。 可以将session理解为一个key-value的机制。 session中的关键点，第一是如何设置和获取key，另外一点就是如何能够保存和获取对应的value。 从key的角度来看，会话会有两种常用的方式，即：sessionId和tokenSessionId:客户端请求服务端时，服务端通过SetCookie就可以在http头中设置sessionId的key和对应的value值,而客户端的cookie会将其保存，后续请求中会自动带上.token:需要手动在http head头里或者url里设置token这个字段，服务器收到请求之后，再从head或url中取出token进行验证。 无论是sessionId还是token，它们都是全局唯一的，一个用户一个标识，本质就是一个key，对应着一个value。 无论key或value，一方没有保持住， 就可能分辨不出用户的身份，获取不到用户的信息，如依赖sessionId时，用户进入了cookie，有可能造成系统不断的让其重新登录，value一方就可能保持不住，因为：分布式系统中的session问题：用户请求通过Nginx到达Tomcat，Tomcat部署一个应用，这时session是保存在这个Tomcat应用的内存中。 那么当一个Tomcat扛不住时，考虑加多台Tomcat服务器，程序该怎么放？ 水平扩展（集群）或者垂直（拆分服务：A有类目商品和订单三个服务，分别部署到不同的服务器上，之后配置Nginx，负载均衡，这样单台服务器压力会小），或者综合。 但是session问题依然存在，如：用户第一次访问A服务器，此时A使用了用户的session，接着用户做第二个请求，由于负载均衡，请求可能到了服务器A1，但是服务器A1上并没有用户的session信息，所以以为该用户没登录。 通用方案：专门的服务保存session信息，其他服务使用session信息实都找他要。通常用redis集群或者主从复制去做的。开发测试时单机版即可。这样无论水平还是垂直， 任何一个应用都可以通过用户的唯一标识来找到用户对应的信息，从而进行后续操作。登录时设置好key，保存好这个用户的信息即value， 登出时让value失效即可。","raw":null,"content":null,"categories":[{"name":"分布式","slug":"分布式","permalink":"http://www.congboss.top/categories/分布式/"}],"tags":[{"name":"分布式系统","slug":"分布式系统","permalink":"http://www.congboss.top/tags/分布式系统/"}]},{"title":"Lonest Substring Without Repeating Characters","slug":"Longest Substring Without Repeating Characters","date":"2018-05-01T03:00:42.000Z","updated":"2018-05-19T07:36:55.784Z","comments":true,"path":"2018/05/01/Longest Substring Without Repeating Characters/","link":"","permalink":"http://www.congboss.top/2018/05/01/Longest Substring Without Repeating Characters/","excerpt":"","text":"Given a string, find the length of the longest substring without repeating characters.12345678910111213class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; Map&lt;Character,Integer&gt; map=new HashMap&lt;&gt;(); int leftBound=0,max=0; for(int i=0;i&lt;s.length();i++)&#123; char c=s.charAt(i); leftBound=Math.max(leftBound,map.containsKey(c)?map.get(c)+1:0); max=Math.max(max,i-leftBound+1); map.put(c,i); &#125; return max; &#125;&#125; 思路：采取滑动窗口的方式，”窗口”向右滑动，每当加到一个新char的时候，左边检查有无重复的char，然后如果没有重复的就正常添加，有重复的话就左边扔掉一部分（从最左到重复char这段扔掉），在这个过程中记录最大窗口长度","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"树的子结构","slug":"树的子结构","date":"2018-04-19T03:00:42.000Z","updated":"2018-07-04T14:44:53.684Z","comments":true,"path":"2018/04/19/树的子结构/","link":"","permalink":"http://www.congboss.top/2018/04/19/树的子结构/","excerpt":"","text":"输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; boolean result=false; //当Tree1和Tree2都不为零的时候，才进行比较。否则直接返回false if( root1!=null &amp;&amp; root2!=null)&#123; //如果找到了对应Tree2的根节点的点 if(root1.val==root2.val)&#123; //以这个根节点为为起点判断是否包含Tree2 result=doesTree1HasTree2(root1,root2); &#125; //如果找不到，那么就再去root的左儿子当作起点，去判断时候包含Tree2 if(!result)&#123; result=HasSubtree(root1.left,root2); &#125; //如果还找不到，那么就再去root的右儿子当作起点，去判断时候包含Tree2 if(!result)&#123; result=HasSubtree(root1.right,root2); &#125; &#125; //返回结果 return result; &#125; public static boolean doesTree1HasTree2(TreeNode node1,TreeNode node2)&#123; //如果Tree2已经遍历完了都能对应的上，返回true if(node2==null)&#123; return true; &#125; //如果Tree2还没有遍历完，Tree1却遍历完了。返回false if(node1==null)&#123; return false; &#125; //如果其中有一个点没有对应上，返回false if(node1.val!=node2.val)&#123; return false; &#125; //如果根节点对应的上，那么就分别去子节点里面匹配 return doesTree1HasTree2(node1.left,node2.left) &amp;&amp; doesTree1HasTree2(node1.right,node2.right); &#125;&#125;","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"递归","slug":"递归","permalink":"http://www.congboss.top/tags/递归/"}]},{"title":"CAS理解","slug":"CAS理解","date":"2018-04-16T04:50:42.000Z","updated":"2018-08-07T16:41:49.083Z","comments":true,"path":"2018/04/16/CAS理解/","link":"","permalink":"http://www.congboss.top/2018/04/16/CAS理解/","excerpt":" 在谈CAS之前，我们谈谈java中的i++、i–这样的操作，我们知道它们不是线程安全的，因为类似的指令会被编译称为2条操作指令，在并发环境下，CPU在执行过程中可能会中断切换到别的线程，无法保证2条操作指令的原子性，所以是线程不安全的。    首先针对这种情况，我们可能第一反应就是利用synchronize关键字实现线程同步，保证++操作的原子性，但是我们今天来谈谈另一种解决办法，利用乐观锁的方式，这就不得不提到另一种选择–AtomicInteger。","text":"在谈CAS之前，我们谈谈java中的i++、i–这样的操作，我们知道它们不是线程安全的，因为类似的指令会被编译称为2条操作指令，在并发环境下，CPU在执行过程中可能会中断切换到别的线程，无法保证2条操作指令的原子性，所以是线程不安全的。 首先针对这种情况，我们可能第一反应就是利用synchronize关键字实现线程同步，保证++操作的原子性，但是我们今天来谈谈另一种解决办法，利用乐观锁的方式，这就不得不提到另一种选择–AtomicInteger。查看源码：首先我们看一下AtomicInteger类的类变量。可以看出有个unsafe的类变量。1234567891011private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\"value\")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value; Unsafe类是用来在任意内存地址位置处读写数据，可见，对于普通用户来说，使用起来还是比较危险的。AtomicInteger类本质就是利用Unsafe.compareAndSwapInt这个CAS操作方法来保证Integer操作的原子性。 看一下AtomicInteger的对int的加法操作。 123456789/** * Atomically adds the given value to the current value. * * @param delta the value to add * @return the updated value */ public final int addAndGet(int delta) &#123; return unsafe.getAndAddInt(this, valueOffset, delta) + delta; &#125; 可以看出调用的是Unsafe类中的getAndAddInt方法，可以继续看看getAndAddInt的实现：123456789public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; &#125;public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); 与众不同的并发策略：比较交换(CAS) 与锁相比，使用CAS会使程序看起来复杂一些。但由于其非阻塞性，它对死锁问题天生免疫，并且，线程间的相互影响也远远小于基于锁的方式。更重要的是，使用无锁的方式完全没有锁竞争带来的系统开销，也没有线程间频繁调度带来的开销，因此，它要比基于锁的方式拥有优越的性能。 CAS包含三个参数：CAS(V,E,N),V：要更新的变量，E：预期值，N：新值。当且仅当V的值与E的值相同时，才会将V的值设置为N，如果V值与E值不同，则说明已经有其他线程做了更新，当前线程什么都不做。 比如，现有t1、t2两个线程， t1和t2线程都同时去访问同一变量56，他们会把主内存的值完全拷贝一份到自己的工作内存空间，所以t1和t2线程的预期值都为56。假设t1在与t2线程竞争中线程t1能去更新变量的值，而其他线程都失败。（失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次发起尝试）。t1线程去更新变量值改为57，然后写到内存中。此时对于t2来说，内存值变为了57，与预期值56不一致，就操作失败了（想改的值不再是原来的值）。 最后，CAS返回当前V的真实值。CAS是抱着乐观的态度进行的，它总是认为自己可以成功完成操作。当多个线程同时是用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。 简单地说，CAS需要你额外给出一个期望值，也就是你认为这个变量现在应该是什么样子的，如果变量不是你想象的那样，那说明它已经被别人修改过了，你就重新读取，再次尝试修改就好了。","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://www.congboss.top/categories/Java/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://www.congboss.top/tags/并发编程/"}]},{"title":"缓存一致性分析","slug":"缓存一致性分析","date":"2018-04-15T11:00:42.000Z","updated":"2018-08-07T16:49:09.510Z","comments":true,"path":"2018/04/15/缓存一致性分析/","link":"","permalink":"http://www.congboss.top/2018/04/15/缓存一致性分析/","excerpt":"CPU缓存到多级缓存的演进：\n为什么需要CPU cache：CPU的频率很快，主存无法跟上它的速度，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源。所以cache的出现，是为了缓解CPU与内存之间速度不匹配的问题（结构：cpu-&gt;cache-&gt;meoory）.","text":"CPU缓存到多级缓存的演进： 为什么需要CPU cache：CPU的频率很快，主存无法跟上它的速度，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源。所以cache的出现，是为了缓解CPU与内存之间速度不匹配的问题（结构：cpu-&gt;cache-&gt;meoory）. CPU cache的意义：（1）时间局部性：如果某个数据被访问，那么在不久的将来它很可能被再次访问（2）空间局部性：如果某个数据被访问，那么与它相邻的数据很快也可能被访问 缓存一致性（MESI）： 用于保证多个CPU cache之间缓存共享数据的一致 MESI（Modified Exclusive Shared Or Invalid）(也称为伊利诺斯协议，是因为该协议由伊利诺斯州立大学提出）是一种广泛使用的支持写回策略的缓存一致性协议 MESI协议中的状态 CPU中每个缓存行（caceh line)使用4种状态进行标记（使用额外的两位(bit)表示): M: 被修改（Modified) 该缓存行只被缓存在该CPU的缓存中，并且是被修改过的（dirty),即与主存中的数据不一致，该缓存行中的内存需要在未来的某个时间点（允许其它CPU读取请主存中相应内存之前）写回（write back）主存。 当被写回主存之后，该缓存行的状态会变成独享（exclusive)状态。 E: 独享的（Exclusive) 该缓存行只被缓存在该CPU的缓存中，它是未被修改过的（clean)，与主存中数据一致。该状态可以在任何时刻当有其它CPU读取该内存时变成共享状态（shared)。同样地，当CPU修改该缓存行中内容时，该状态可以变成Modified状态。 S:共享的（Shared) 该状态意味着该缓存行可能被多个CPU缓存，并且各个缓存中的数据与主存数据一致（clean)，当有一个CPU修改该缓存行中，其它CPU中该缓存行可以被作废（变成无效状态（Invalid））。 I: 无效的（Invalid） 该缓存是无效的（可能有其它CPU修改了该缓存行）。在一个典型系统中，可能会有几个缓存（在多核系统中，每个核心都会有自己的缓存）共享主存总线，每个相应的CPU会发出读写请求，而缓存的目的是为了减少CPU读写共享主存的次数。 一个缓存除在Invalid状态外都可以满足cpu的读请求，一个invalid的缓存行必须从主存中读取（变成S或者 E状态）来满足该CPU的读请求。 一个写请求只有在该缓存行是M或者E状态时才能被执行，如果缓存行处于S状态，必须先将其它缓存中该缓存行变成Invalid状态（也既是不允许不同CPU同时修改同一缓存行， 即使修改该缓存行中不同位置的数据也不允许）。该操作经常作用广播的方式来完成，例如：RequestFor Ownership (RFO) 缓存可以随时将一个非M状态的缓存行作废，或者变成Invalid状态，而一个M状态的缓存行必须先被写回主存。 一个处于M状态的缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S状态之前被延迟执行。 一个处于S状态的缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。 一个处于E状态的缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S状态。 对于M和E状态而言总是精确的，他们在和该缓存行的真正状态是一致的。而S状态可能是非一致的，如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为E状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的copy的数量， 因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。 从上面的意义看来E状态是一种投机性的优化：如果一个CPU想修改一个处于S状态的缓存行，总线事务需要将所有该缓存行的copy变成invalid状态，而修改E状态的缓存不需要使用总线事务。","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://www.congboss.top/categories/Java/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://www.congboss.top/tags/并发编程/"}]},{"title":"Java高并发容器合集","slug":"java并发容器合集","date":"2018-04-10T11:00:42.000Z","updated":"2018-08-07T16:43:34.615Z","comments":true,"path":"2018/04/10/java并发容器合集/","link":"","permalink":"http://www.congboss.top/2018/04/10/java并发容器合集/","excerpt":"概述   java.util包中的大部分容器都是非线程安全的，若要在多线程中使用容器，你可以使用Collections提供的包装函数：synchronizedXXX，将普通容器变成线程安全的容器。但该方法仅仅是简单地给容器使用同步，效率很低。因此并发大师Doug Lea提供了java.util.concurrent包，提供高效的并发容器。并且为了保持与普通的容器的接口一致性，仍然使用util包的接口，从而易于使用、易于理解。PS：问题：synchronizedXXX究竟对容器做了什么从而能达到线程安全的目的？","text":"概述 java.util包中的大部分容器都是非线程安全的，若要在多线程中使用容器，你可以使用Collections提供的包装函数：synchronizedXXX，将普通容器变成线程安全的容器。但该方法仅仅是简单地给容器使用同步，效率很低。因此并发大师Doug Lea提供了java.util.concurrent包，提供高效的并发容器。并且为了保持与普通的容器的接口一致性，仍然使用util包的接口，从而易于使用、易于理解。PS：问题：synchronizedXXX究竟对容器做了什么从而能达到线程安全的目的？ 类图List和Set JUC包中List接口的实现类：CopyOnWriteArrayList CopyOnWriteArrayList是线程安全的ArrayList JUC包中Set接口的实现类：CopyOnWriteArraySet、ConcurrentSkipListSet CopyOnWriteArraySet是线程安全的Set，它内部包含了一个CopyOnWriteArrayList，因此本质上是由CopyOnWriteArrayList实现的。 ConcurrentSkipListSet相当于线程安全的TreeSet。它是有序的Set。它由ConcurrentSkipListMap实现。 Map ConcurrentHashMap：线程安全的HashMap。采用分段锁实现高效并发。 ConcurrentSkipListMap：线程安全的有序Map。使用跳表实现高效并发。 Queue ConcurrentLinkedQueue：线程安全的无界队列。底层采用单链表。支持FIFO。 ConcurrentLinkedDeque：线程安全的无界双端队列。底层采用双向链表。支持FIFO和FILO。 ArrayBlockingQueue：数组实现的阻塞队列。 LinkedBlockingQueue：链表实现的阻塞队列。 LinkedBlockingDeque：双向链表实现的双端阻塞队列。 CopyOnWrite容器（写时复制容器）CopyOnWrite容器包括：CopyOnWriteArrayList和CopyOnWriteArraySet。 PS：CopyOnWriteArraySet有CopyOnWriteArrayList实现。 特性 适用于读操作远远多于写操作，并且数据量较小的情况。 修改容器的代价是昂贵的，因此建议批量增加addAll、批量删除removeAll。 CopyOnWrite容器是如何实现线程安全的？ 使用volatile修饰数组引用：确保数组引用的内存可见性。 对容器修改操作进行同步：从而确保同一时刻只能有一条线程修改容器（因为修改容器都会产生一个新的容器，增加同步可避免同一时刻复制生成多个容器，从而无法保证数组数据的一致性） 修改时复制容器：确保所有修改操作都作用在新数组上，原本的数组在创建过后就用不变化，从而其他线程可以放心地读。 新增方法CopyOnWriteArrayList：1234// 添加集合中不存在的元素int addAllAbsent(Collection&lt;? extends E&gt; c)// 该元素若不存在则添加boolean addIfAbsent(E e) CopyOnWriteArraySet：木有新增！ 迭代 CopyOnWriteArrayList拥有内部类：COWIterator，它是ListIterator的子类。 当调用iterator函数时返回的是COWIterator对象。 COWIterator不允许修改容器，你若调用则会抛出UnsupportedOperationException。 优点读操作无需加锁，从而高效。 缺点 数据一致性问题 由于迭代的是容器当前的快照，因此在迭代过程中容器发生的修改并不能实时被当前正在迭代的线程感知。 内存占用问题 由于修改容器都会复制数组，从而当数组超大时修改容器效率很低。 PS：因此写时复制容器适合存储小容量数据。 ConcurrentHashMapjava.util包中提供了线程安全的HashTable，但这家伙只是通过简单的同步来实现线程安全，因此效率低。只要有一条线程获取了容器的锁之后，其他所有的线程访问同步函数都会被阻塞。因此同一时刻只能有一条线程访问同步函数。而ConcurrentHashMap采用了分段锁机制实现高效的并发访问。 分段锁原理ConcurrentHashMap由多个Segment构成，每个Segment都包含一张哈希表。每次操作只将操作数据所属的Segment锁起来，从而避免将整个锁住。数据结构 ConcurrentHashMap内部包含了Segment数组，而每个Segment又继承自ReentrantLock，因此它是一把可重入的锁。 Segment内部拥有一个HashEntry数组，它就是一张哈希表。HashEntry是单链表的一个节点，HashEntry数组存储单链表的表头节点。 新增API1V putIfAbsent(K key, V value) ConcurrentSkipListMap 它是一个有序的Map，相当于TreeMap。 TreeMap采用红黑树实现排序，而ConcurrentHashMap采用跳表实现有序。 跳表的由来作用：存储有序序列，并且实现高效的查找与插入删除。存储有序序列最简单的办法就是使用数组，从而查找可以采用二分搜索，但插入删除需要移动元素较为低效。因此出现了二叉搜索树，用来解决插入删除移动元素的问题。但二叉搜索树在最坏情况下会退化成一条单链表，搜索的效率降为O(n)。为了避免二叉搜索树的退化，出现了二叉平衡树，它在每次插入删除节点后都会重新调整树形，使得它仍然保持平衡，从而保证了搜索效率，也保证了插入删除的效率。此外，根据平衡算法的不同，二叉平衡树又分为：B+树、B-树、红黑树。但平衡算法过于复杂，因此出现跳表。 跳表介绍跳表是条有序的单链表，它的每个节点都有多个指向后继节点的引用。它有多个层次，上层都是下层的子集，从而能跳过不必要的节点，提升搜索速度。它通过空间来换取时间。如查找19的过程： ConcurrentSkipListSet 它是一个有序的、线程安全的Set，相当于线程安全的TreeSet。 它内部拥有ConcurrentSkipListMap实例，本质上就是一个ConcurrentSkipListMap，只不过仅使用了Map中的key。 ArrayBlockingQueue概要 ArrayBlockingQueue是一个 数组实现的 线程安全的 有限 阻塞队列。 数据结构 ArrayBlockingQueue继承自AbstractQueue，并实现了BlockingQueue接口。 ArrayBlockingQueue内部由Object数组存储元素，构造时必须要指定队列容量。 ArrayBlockingQueue由ReentrantLock实现队列的互斥访问，并由notEmpty、notFull这两个Condition分别实现队空、队满的阻塞。 ReentrantLock分为公平锁和非公平锁，可以在构造ArrayBlockingQueue时指定。默认为非公平锁。 新增API12345678// 在队尾添加指定元素，若队已满则等待指定时间boolean offer(E e, long timeout, TimeUnit unit)// 获取并删除队首元素，若队为空则阻塞等待E take()// 添加指定元素，若队已满则一直等待void put(E e)// 获取队首元素，若队为空，则等待指定时间E poll(long timeout, TimeUnit unit) 队满、队空阻塞唤醒的原理 队满阻塞：当添加元素时，若队满，则调用notFull.await()阻塞当前线程；当移除一个元素时调用notFull.signal()唤醒在notFull上等待的线程。 队空阻塞：当删除元素时，若队为空，则调用notEmpty.await()阻塞当前线程；当队首添加元素时，调用notEmpty.signal()唤醒在notEmpty上等待的线程。 LinkedBlockingQueue 概要 LinkedBlockingQueue是一个 单链表实现的、线程安全的、无限 阻塞队列。 数据结构 LinkedBlockingQueue继承自AbstractQueue，实现了BlockingQueue接口。 LinkedBlockingQueue由单链表实现，因此是个无限队列。但为了方式无限膨胀，构造时可以加上容量加以限制。 LinkedBlockingQueue分别采用读取锁和插入锁控制读取/删除 和 插入过程的并发访问，并采用notEmpty和notFull两个Condition实现队满队空的阻塞与唤醒。 队满队空阻塞唤醒的原理 队满阻塞：若要插入元素，首先需要获取putLock；在此基础上，若此时队满，则调用notFull.await()，阻塞当前线程；当移除一个元素后调用notFull.signal()唤醒在notFull上等待的线程；最后，当插入操作完成后释放putLock。 队空阻塞：若要删除/获取元素，首先要获取takeLock；在此基础上，若队为空，则调用notEmpty.await()，阻塞当前线程；当插入一个元素后调用notEmpty.signal()唤醒在notEmpty上等待的线程；最后，当删除操作完成后释放takeLock。 PS：API和ArrayBlockingQueue一样。 LinkedBlockingDeque概要 它是一个 由双向链表实现的、线程安全的、 双端 无限 阻塞队列。 数据结构 ConcurrentLinkedQueue概述 它是一个由单链表实现的、线程安全的、无限 队列。 数据结构 它仅仅继承了AbstractQueue，并未实现BlockingQueue接口，因此它不是阻塞队列，仅仅是个线程安全的普通队列。 特性 head、tail、next、item均使用volatile修饰，保证其内存可见性，并未使用锁，从而提高并发效率。 PS：它究竟是怎样在不使用锁的情况下实现线程安全的？","raw":null,"content":null,"categories":[{"name":"高并发编程","slug":"高并发编程","permalink":"http://www.congboss.top/categories/高并发编程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.congboss.top/tags/Java/"},{"name":"高并发","slug":"高并发","permalink":"http://www.congboss.top/tags/高并发/"}]},{"title":"常见排序算法总结","slug":"常见排序算法总结","date":"2018-04-01T03:00:42.000Z","updated":"2018-09-09T16:16:12.114Z","comments":true,"path":"2018/04/01/常见排序算法总结/","link":"","permalink":"http://www.congboss.top/2018/04/01/常见排序算法总结/","excerpt":"一、冒泡排序冒泡排序原理：\n比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n针对所有的元素重复以上的步骤，除了最后一个。\n持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。","text":"一、冒泡排序冒泡排序原理： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 Java代码实现：123456789101112public static void BubbleSort(int[] nums) &#123; for (int i = 0; i &lt; nums.length - 1; i++) &#123; for (int j = 1; j &lt; nums.length - i; j++) &#123; if (nums[j] &lt; nums[j - 1]) &#123; int temp = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = temp; &#125; &#125; &#125;&#125; 冒泡排序时间空间复杂度及算法稳定性分析对于长度为 n 的数组，冒泡排序需要经过 n(n-1)/2 次比较，最坏的情况下，即数组本身是倒序的情况下，需要经过 n(n-1)/2 次交换，所以: 冒泡排序的算法时间平均复杂度为O(n²)。空间复杂度为 O(1)。 可以想象一下：如果两个相邻的元素相等是不会进行交换操作的，也就是两个相等元素的先后顺序是不会改变的。如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个元素相邻起来，最终也不会交换它俩的位置，所以相同元素经过排序后顺序并没有改变。所以冒泡排序是一种稳定排序算法。所以冒泡排序是稳定排序。这也正是算法稳定性的定义： 排序算法的稳定性：通俗地讲就是能保证排序前两个相等的数据其在序列中的先后位置顺序与排序后它们两个先后位置顺序相同。 二、选择排序选择排序是另一种简单的排序算法。选择排序之所以叫选择排序就是在一次遍历过程中找到最小元素的角标位置，然后把它放到数组的首端。我们排序过程都是在寻找剩余数组中的最小元素，所以就叫做选择排序。 选择排序的思想选择排序的思想也很简单： 从待排序序列中，找到关键字最小的元素；起始假定第一个元素为最小 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换； 从余下的 N - 1 个元素中，找出关键字最小的元素，重复1，2步，直到排序结束。 Java代码实现：1234567891011121314public static void selectSort(int[] nums) &#123; int n = nums.length; for (int i = 0; i &lt; n - 1; i++) &#123; int index = i; for (int j = i + 1; j &lt; n; j++) &#123; if (nums[j] &lt; nums[index]) &#123; index = j; &#125; &#125; int temp = nums[index]; nums[index] = nums[i]; nums[i] = temp; &#125;&#125; 选择排序时间空间复杂度及算法稳定性分析上述 java 代码可以看出我们除了交换元素并未开辟额外的空间，所以额外的空间复杂度为O(1)。对于时间复杂度而言，选择排序序冒泡排序一样都需要遍历 n(n-1)/2 次,但是相对于冒泡排序来说每次遍历只需要交换一次元素，这对于计算机执行来说有一定的优化。但是选择排序也是名副其实的慢性子，即使是有序数组，也需要进行 n(n-1)/2 次比较，所以其时间复杂度为O(n²)。即便无论如何也要进行n(n-1)/2 次比较，选择排序仍是不稳定的排序算法，我们举一个例子如：序列5 8 5 2 9， 我们知道第一趟选择第1个元素5会与2进行交换，那么原序列中两个5的相对先后顺序也就被破坏了。 选择排序总结： 选择排序的算法时间平均复杂度为O(n²)。 选择排序空间复杂度为 O(1)。 选择排序为不稳定排序。 三、插入排序对于插入排序，大部分资料都是使用扑克牌整理作为例子来引入的，我们打牌都是一张一张摸牌的，没摸到一张牌就会跟手里所有的牌比较来选择合适的位置插入这张牌，这也就是直接插入排序的中心思想。 插入排序的思想 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤 2~5 Java代码实现：1234567891011private static void insertSort(int[] nums) &#123; int n = nums.length; for (int i = 0; i &lt; n; i++) &#123; int temp = nums[i]; int j = i; for (; j &gt; 0 &amp;&amp; nums[j - 1] &gt; temp; j--) &#123; nums[j] = nums[j - 1]; &#125; nums[j] = temp; &#125;&#125; 插入排序的时间复杂度和空间复杂度分析对于插入的时间复杂度和空间复杂度，通过代码就可以看出跟选择和冒泡来说没什么区别同属于 O(n²) 级别的时间复杂度算法 ，只是遍历方式有原来的 n n-1 n-2 … 1，变成了 1 2 3 … n 了。最终得到时间复杂度都是 n(n-1)/2。对于稳定性来说，插入排序和冒泡一样，并不会改变原有的元素之间的顺序，如果遇见一个与插入元素相等的，那么把待插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序仍是排好序后的顺序，所以插入排序是稳定的。对于插入排序这里说一个非常重要的一点就是：由于这个算法可以提前终止内层比较（ arr[j-1] &gt; arr[j]）所以这个排序算法很有用！因此对于一些 NlogN 级别的算法，后边的归并和快速都属于这个级别的，算法来说对于 n 小于一定级别的时候（Array.sort 中使用的是47）都可以用插入算法来优化,另外对于近乎有序的数组来说这个提前终止的方式就显得更加又有优势了。 插入排序总结：插入排序的算法时间平均复杂度为O(n²)。插入排序空间复杂度为 O(1)。插入排序为稳定排序。插入排序对于近乎有序的数组来说效率更高，插入排序可用来优化高级排序算法 四、归并排序前面介绍的排序算法都是O(n²)的排序算法，下面我们一个NlogN级别的算法，归并算法。 归并算法正如其名字一样采用归并的方法进行排序：我们总是可以将一个数组一分为二，然后二分为四直到，每一组只有两个元素，这可以理解为个递归的过程，然后将两个元素进行排序，之后再将两个元素为一组进行排序。直到所有的元素都排序完成。 归并算法的思想归并算法其实可以分为递归法和迭代法（自低向上归并），两种实现对于最小集合的归并操作思想是一样的区别在于如何划分数组，我们先介绍下算法最基本的操作： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤3直到某一指针到达序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 假设我们现在在对一个数组的 arr[l…r] 部分进行归并，按照上述归并思想我们可将数组分为两部分 假设为 arr[l…mid] 和 arr[mid+1…r]两部分，注意这两部分可能长度并不相同，因为基数个数的数组划分的时候总是能得到一个 长度为1 和长度为2 的部分进行归并.那么我们按照上述思路进行代码编写： Java代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 将arr[l...mid]和arr[mid+1...r]两部分进行归并public static void merge(int[] arr, int l, int mid, int r) &#123; int[] nums = new int[r - l + 1]; for (int i = l; i &lt;= r; i++) &#123; nums[i - l] = arr[i]; &#125; // 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1 int i = l, j = mid + 1; for (int k = l; k &lt;= r; k++) &#123; // 如果右半部分元素已经全部处理完毕 if (i &gt; mid) &#123; arr[k] = nums[j - l]; j++; &#125; // 如果右半部分元素已经全部处理完毕 else if (j &gt; r) &#123; arr[k] = nums[i - l]; i++; &#125; // 左半部分所指元素 &lt; 右半部分所指元素 else if (nums[i - l] &lt; nums[j - l]) &#123; arr[k] = nums[i - l]; i++; &#125; // 左半部分所指元素 &gt;= 右半部分所指元素 else &#123; arr[k] = nums[j - l]; j++; &#125; &#125;&#125;private static void mergeSort(int[] arr, int l, int r) &#123; if (l &gt;= r) &#123; return; &#125; int mid = (l + r) / 2; mergeSort(arr, l, mid); mergeSort(arr, mid + 1, r);//优化点1.检查是否上一步归并完的数组是否有序，如果有序则直接进行下一次归并 if (arr[mid] &lt;= arr[mid + 1]) &#123; return; &#125; merge(arr, l, mid, r);&#125;public static void mergeSort(int[] arr) &#123; int n = arr.length; mergeSort(arr, 0, n - 1);&#125; 这里对于归并排序还有一些可以改进的地方：1.检查归并的左右两边的数组大小，如果arr[mid] &lt;= arr[mid + 1]，也就代表着归并已经完成，直接完成归并。2.当我们递归到元素量非常小的时候，可以转而使用插入排序，因为数组比较小的时候，数组近乎有序的概率比较大，再者，数据量比较小的时候，插入排序快于归并排序，具体的数组大小需要根据测试用例的大小来判断。 自底向上迭代实现：对于迭代实现归并其实和递归实现有所不同，迭代的时候我们是将数组分为 一个一个的元素，然后每两个归并一次，第二次我们将数组每两个分一组，两个两个的归并，知道分组大小等于待归并数组长度为止，即先局部排序，逐步扩大到全局排序12345678910111213141516171819202122232425262728293031323334353637383940414243public static void merge(int[] arr, int l, int mid, int r) &#123; int[] nums = new int[r - l + 1]; for (int i = l; i &lt;= r; i++) &#123; nums[i - l] = arr[i]; &#125; // 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1 int i = l, j = mid + 1; for (int k = l; k &lt;= r; k++) &#123; // 如果右半部分元素已经全部处理完毕 if (i &gt; mid) &#123; arr[k] = nums[j - l]; j++; &#125; // 如果右半部分元素已经全部处理完毕 else if (j &gt; r) &#123; arr[k] = nums[i - l]; i++; &#125; // 左半部分所指元素 &lt; 右半部分所指元素 else if (nums[i - l] &lt; nums[j - l]) &#123; arr[k] = nums[i - l]; i++; &#125; // 左半部分所指元素 &gt;= 右半部分所指元素 else &#123; arr[k] = nums[j - l]; j++; &#125; &#125; &#125; public static void mergeSortBU(int[] arr) &#123; int n = arr.length; for (int sz = 1; sz &lt; n; sz *= 2) &#123; for (int i = 0; i &lt; n - sz; i += sz * 2) &#123;// 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge if (arr[i + sz - 1] &gt; arr[i + sz]) &#123; merge(arr, i, i + sz - 1, Math.min(i + sz * 2 - 1, n - 1)); &#125; &#125; &#125; &#125; 比如我们看第一次是 sz = 1 个长度的归并即 i = 0 i = 1 的元素归并 下次归并应该为 i= 2 i = 3 一次类推 所以内层循环 i 每次应该递增 两个 sz 那么大 为了避免角标越界且保证归并的右半部分存在 所以 i + sz &lt; n ,又考虑到数组长度为奇数的情况，所以右半边的右边为 Math.min(i + sz + sz - 1, n - 1)； 归并排序的时间复杂度和空间复杂度分析其实对于归并排序的时间复杂对有一个递归公式来推断出时间复杂度，但简单来讲假设数组长度为 N ，那么我们就有 logN 次划分区间，而最终会划分为常数 级别的归并，将所有层的归并时间加起来得到了一个 NlogN.对于空间复杂度，我们通过算法实现可以看出我们归并过程申请了 长度为 N 的临时数组，来进行归并所以空间复杂度为 O(n);又由于我们在排序过程中对于 nums[i - l] = nums[j - l] 并没有进行位置交换直接取得靠前的元素先赋值，所以算法是稳定的。 归并排序总结: 归并排序的算法时间平均复杂度为O(nlog(n))。 归并排序空间复杂度为 O(n)。 归并排序为稳定排序。","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"单例模式","slug":"单例模式","date":"2018-03-01T03:00:42.000Z","updated":"2019-05-12T12:10:36.105Z","comments":true,"path":"2018/03/01/单例模式/","link":"","permalink":"http://www.congboss.top/2018/03/01/单例模式/","excerpt":"12345678public class SingleTon &#123;     private SingleTon()&#123;             &#125;          public static SingleTon getInstance()&#123;        return new SingleTon();     &#125; &#125;","text":"12345678public class SingleTon &#123; private SingleTon()&#123; &#125; public static SingleTon getInstance()&#123; return new SingleTon(); &#125; &#125; 1.懒汉式单例模式 123456789101112131415@NotThreadSafepublic class SingletonExample1 &#123; //私有构造函数 private SingletonExample1()&#123; &#125; //单例对象 private static SingletonExample1 instance=null;//静态工厂方法 public static SingletonExample1 getInstance()&#123; if(instance==null)&#123; instance=new SingletonExample1(); &#125; return instance; &#125;&#125; 2.饿汉式单例模式 123456789101112@ThreadSafepublic class SingleTonExample2 &#123; //私有构造函数 private SingleTonExample2()&#123; &#125;//单例对象 private static SingleTonExample2 singleTonExample2=new SingleTonExample2();//静态工厂方法 public static SingleTonExample2 getInstance() &#123; return singleTonExample2; &#125;&#125; 上述两种单例模式中，饿汉式单例模式是线程安全的，而懒汉式单例模式则不然。可以通常下述两种方式让懒汉式单例模式变得安全：一.使用synchronized来处理。也就是说将getInstance()方法变成同步方法即可。12345678910111213141516@ThreadSafe@NotRecommendpublic class SingleTonExample3 &#123; //私有构造函数 private SingleTonExample3()&#123; &#125; //单例对象 public static SingleTonExample3 singleTonExample3=null; //静态工厂方法 public static synchronized SingleTonExample3 getSingleTonExample3()&#123; if(singleTonExample3==null)&#123; singleTonExample3=new SingleTonExample3(); &#125; return singleTonExample3; &#125;&#125; 二、 用“双重检查加锁”，在getInstance()中减少使用同步。12345678910111213141516171819202122232425262728@NotThreadSafepublic class SingletonExample4 &#123; //私有构造函数 private SingletonExample4()&#123; &#125; //1.memory=allocate() 分配对象的内存空间 //2.ctorInstance()初始化对象 //3.instance=memory 设置instance指向刚分配的内存 //jvm和cpu优化，发生了指令重排 //1.memory=allocate() 分配对象的内存空间 //3.instance=memory 设置instance指向刚分配的内存 //2.ctorInstance()初始化对象 //单例对象 private static SingletonExample4 instance=null;//静态工厂方法 public static SingletonExample4 getInstance()&#123; if(instance==null)&#123;//双重锁检查机制 synchronized (SingletonExample4.class)&#123;//同步锁 if(instance==null)&#123; instance=new SingletonExample4(); &#125; &#125; &#125; return instance; &#125;&#125; 在注释中也讲了，因为指令重排的可能性，这种方式并不能保证线程安全。解决的办法也很简单，使用volatile关键字加上指令重排就可以阻止指令重排。12345678910111213141516171819202122232425262728@ThreadSafepublic class SingletonExample5 &#123; //私有构造函数 private SingletonExample5()&#123; &#125; //1.memory=allocate() 分配对象的内存空间 //2.ctorInstance()初始化对象 //3.instance=memory 设置instance指向刚分配的内存 //jvm和cpu优化，发生了指令重排 //1.memory=allocate() 分配对象的内存空间 //3.instance=memory 设置instance指向刚分配的内存 //2.ctorInstance()初始化对象 //单例对象 private static volatile SingletonExample5 instance=null;//volatile+双重检测-&gt;不允许指令重排//静态工厂方法 public static SingletonExample5 getInstance()&#123; if(instance==null)&#123;//双重锁检查机制 synchronized (SingletonExample5.class)&#123;//同步锁 if(instance==null)&#123; instance=new SingletonExample5(); &#125; &#125; &#125; return instance; &#125;&#125; 3.枚举方式12345678910111213141516171819202122@ThreadSafe@Recommendpublic class SingleTonExample7 &#123; private SingleTonExample7()&#123; &#125; public static SingleTonExample7 getInstance()&#123;return SingleTon.INSTANCE.getInstance(); &#125; private enum SingleTon&#123; INSTANCE; private SingleTonExample7 singleTon;//JVM保证这个方法绝对只调用一次 SingleTon()&#123; singleTon=new SingleTonExample7(); &#125; public SingleTonExample7 getInstance()&#123; return singleTon; &#125; &#125;&#125; 这是推荐的也是最安全的使用单例模式的方法，原因写在注释中，因为JVM保证SingleTon()方法绝对只调用一次,我们不需要添加任何额外的措施就可以保证安全。 单例模式优缺点： 优点：一、节约了系统资源。由于系统中只存在一个实例对象，对与一些需要频繁创建和销毁对象的系统而言，单例模式无疑节约了系统资源和提高了系统的性能。二、因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。 缺点：一、由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。二、单例类的职责过重，在一定程度上违背了“单一职责原则”。","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.congboss.top/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.congboss.top/tags/设计模式/"}]},{"title":"HashMap","slug":"HashMap相关讲解","date":"2018-02-27T10:02:23.000Z","updated":"2018-08-07T16:42:29.227Z","comments":true,"path":"2018/02/27/HashMap相关讲解/","link":"","permalink":"http://www.congboss.top/2018/02/27/HashMap相关讲解/","excerpt":"本文转载自：https://zhuanlan.zhihu.com/p/21673805\n摘要HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。\n简介Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：","text":"本文转载自：https://zhuanlan.zhihu.com/p/21673805 摘要HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。 简介Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：下面针对各个实现类的特点做一些说明： (1) HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 (2) Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 (3) LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 (4) TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。 通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。 内部实现搞清楚HashMap，首先需要知道HashMap是什么，即它的存储结构-字段；其次弄明白它能干什么，即它的功能实现-方法。下面我们针对这两个方面详细展开讲解。 存储结构-字段从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？ (1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。1234567891011121314static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; //用来定位数组索引位置 final K key; V value; Node&lt;K,V&gt; next; //链表的下一个node Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125; public final K getKey()&#123; ... &#125; public final V getValue() &#123; ... &#125; public final String toString() &#123; ... &#125; public final int hashCode() &#123; ... &#125; public final V setValue(V newValue) &#123; ... &#125; public final boolean equals(Object o) &#123; ... &#125;&#125; Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。 (2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码：1map.put(\"美团\",\"小美\"); 系统将调用”美团”这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。 如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。 在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：1234int threshold; // 所能容纳的key-value对极限 final float loadFactor; // 负载因子 int modCount; int size; 首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。 结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。 size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。 在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考http://blog.csdn.net/liuqiyao_01/article/details/14475159， Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。 这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。 功能实现-方法HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。 确定哈希桶数组索引位置 不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):1234567891011方法一：static final int hash(Object key) &#123; //jdk1.8 &amp; jdk1.7 int h; // h = key.hashCode() 为第一步 取hashCode值 // h ^ (h &gt;&gt;&gt; 16) 为第二步 高位参与运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;方法二：static int indexFor(int h, int length) &#123; //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的 return h &amp; (length-1); //第三步 取模运算&#125; 这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。 对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。 **这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。 在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。** 下面举例说明下，n为table的长度。 分析HashMap的put方法HashMap的put方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。 ①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容； ②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③； ③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals； ④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤； ⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； ⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。 JDK1.8HashMap的put方法源码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public V put(K key, V value) &#123; // 对key的hashCode()做hash return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 步骤①：tab为空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 步骤②：计算index，并对null做处理 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; // 步骤③：节点key存在，直接覆盖value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 步骤④：判断该链为红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 步骤⑤：该链为链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key,value,null); //链表长度大于8转换为红黑树进行处理 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // key已经存在直接覆盖value if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 步骤⑥：超过最大容量 就扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 扩容机制 扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。 我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。12345678910111213 void resize(int newCapacity) &#123; //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; &#125; Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值&#125; 这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。1234567891011121314151617 void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null); &#125; &#125;&#125; newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。 下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\"，\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // 链表优化重hash的代码块 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 线程安全性在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：1234567891011121314151617181920public class HashMapInfiniteLoop &#123; private static HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(2，0.75f); public static void main(String[] args) &#123; map.put(5， \"C\"); new Thread(\"Thread1\") &#123; public void run() &#123; map.put(7, \"B\"); System.out.println(map); &#125;; &#125;.start(); new Thread(\"Thread2\") &#123; public void run() &#123; map.put(3, \"A); System.out.println(map); &#125;; &#125;.start(); &#125; &#125; 其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。 通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。 线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。 JDK1.8与JDK1.7的性能对比HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7，下面我们从两个方面用例子证明这一点。 Hash较均匀的情况为了便于测试，我们先写一个类Key，如下：123456789101112131415161718192021222324252627class Key implements Comparable&lt;Key&gt; &#123; private final int value; Key(int value) &#123; this.value = value; &#125; @Override public int compareTo(Key o) &#123; return Integer.compare(this.value, o.value); &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Key key = (Key) o; return value == key.value; &#125; @Override public int hashCode() &#123; return value; &#125;&#125; 这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同，因为直接使用value当做hashcode。为了避免频繁的GC，我将不变的Key实例缓存了起来，而不是一遍一遍的创建它们。代码如下：123456789101112131415public class Keys &#123; public static final int MAX_KEY = 10_000_000; private static final Key[] KEYS_CACHE = new Key[MAX_KEY]; static &#123; for (int i = 0; i &lt; MAX_KEY; ++i) &#123; KEYS_CACHE[i] = new Key(i); &#125; &#125; public static Key of(int value) &#123; return KEYS_CACHE[value]; &#125;&#125; 现在开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、……10000000），屏蔽了扩容的情况，代码如下：1234567891011121314151617181920static void test(int mapSize) &#123; HashMap&lt;Key, Integer&gt; map = new HashMap&lt;Key,Integer&gt;(mapSize); for (int i = 0; i &lt; mapSize; ++i) &#123; map.put(Keys.of(i), i); &#125; long beginTime = System.nanoTime(); //获取纳秒 for (int i = 0; i &lt; mapSize; i++) &#123; map.get(Keys.of(i)); &#125; long endTime = System.nanoTime(); System.out.println(endTime - beginTime); &#125; public static void main(String[] args) &#123; for(int i=10;i&lt;= 1000 0000;i*= 10)&#123; test(i); &#125; &#125; 在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响。结果如下：通过观测测试结果可知，JDK1.8的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。由于Hash算法较均匀，JDK1.8引入的红黑树效果不明显，下面我们看看Hash不均匀的的情况。 Hash极不均匀的情况假设我们又一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下：123456789class Key implements Comparable&lt;Key&gt; &#123; //... @Override public int hashCode() &#123; return 1; &#125;&#125; 仍然执行main方法，得出的结果如下表所示：从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。 测试环境：处理器为2.2 GHz Intel Core i7，内存为16 GB 1600 MHz DDR3，SSD硬盘，使用默认的JVM参数，运行在64位的OS X 10.10.1上。 小结(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。 (2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。 (3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。 (4) JDK1.8引入红黑树大程度优化了HashMap的性能。 (5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://www.congboss.top/categories/Java/"}],"tags":[{"name":"集合相关","slug":"集合相关","permalink":"http://www.congboss.top/tags/集合相关/"}]},{"title":"硬币找零","slug":"硬币找零","date":"2018-02-20T03:00:42.000Z","updated":"2018-03-27T07:45:16.424Z","comments":true,"path":"2018/02/20/硬币找零/","link":"","permalink":"http://www.congboss.top/2018/02/20/硬币找零/","excerpt":"","text":"You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1:coins = [1, 2, 5], amount = 11return 3 (11 = 5 + 5 + 1) Example 2:coins = [2], amount = 3return -1. Note:You may assume that you have an infinite number of each kind of coin.12345678910111213141516171819202122232425262728293031class Solution &#123; Map&lt;Integer,Integer&gt; cache=new HashMap&lt;&gt;(); public int coinChange(int [] coins,int amount) &#123; if(amount==0) &#123; return 0; &#125; if(cache.containsKey(amount)) return cache.get(amount); int count=amount+1; for(int coin:coins) &#123; int cur=0; if(coin&lt;=amount) &#123; int next=coinChange(coins,amount-coin) ; if(next&gt;=0) &#123; cur=next+1; &#125; &#125; if(cur&gt;0) &#123;count=Math.min(count,cur);&#125; &#125; int res=(count==amount+1)?-1:count; cache.put(amount,res); return res; &#125; &#125;","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.congboss.top/tags/动态规划/"}]},{"title":"旋转数组","slug":"旋转数组","date":"2018-02-20T03:00:42.000Z","updated":"2018-09-19T08:35:21.187Z","comments":true,"path":"2018/02/20/旋转数组/","link":"","permalink":"http://www.congboss.top/2018/02/20/旋转数组/","excerpt":"给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。","text":"给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。1234567891011121314151617class Solution &#123; public void rotate(int[] nums, int k) &#123; int n=nums.length; k %=n;//防止m大于数组的长度从而产生异常 reverse(nums,0,n-1); reverse(nums,0,k-1); reverse(nums,k,n-1); &#125;//数组反转 private void reverse(int [] nums,int i,int j)&#123; while(i&lt;j)&#123; int temp=nums[i]; nums[i++]=nums[j]; nums[j--]=temp; &#125; &#125;&#125;","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"平面列表","slug":"平面列表","date":"2018-02-19T03:00:42.000Z","updated":"2018-03-24T05:05:34.483Z","comments":true,"path":"2018/02/19/平面列表/","link":"","permalink":"http://www.congboss.top/2018/02/19/平面列表/","excerpt":"","text":"给定一个列表，该列表中的每个要素要么是个列表，要么是整数。将其变成一个只包含整数的简单列表。 样例给定 [1,2,[1,2]]，返回 [1,2,1,2]。 给定 [4,[3,[2,[1]]]]，返回 [4,3,2,1]。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * public interface NestedInteger &#123; * * // @return true if this NestedInteger holds a single integer, * // rather than a nested list. * public boolean isInteger(); * * // @return the single integer that this NestedInteger holds, * // if it holds a single integer * // Return null if this NestedInteger holds a nested list * public Integer getInteger(); * * // @return the nested list that this NestedInteger holds, * // if it holds a nested list * // Return null if this NestedInteger holds a single integer * public List&lt;NestedInteger&gt; getList(); * &#125; */public class Solution &#123; // @param nestedList a list of NestedInteger // @return a list of integer public List&lt;Integer&gt; flatten(List&lt;NestedInteger&gt; nestedList) &#123; // Write your code here List&lt;Integer&gt; res=new ArrayList&lt;&gt;(); res=tree(res,nestedList); return res; &#125; public List&lt;Integer&gt; tree(List&lt;Integer&gt; res,List&lt;NestedInteger&gt; nestedList) &#123; //if(nestedList==null||nestedList.isEmpty()) //return null; for(NestedInteger item:nestedList) &#123; if(item.isInteger()) &#123; res.add(item.getInteger()); &#125; else &#123; tree(res,item.getList()); &#125; &#125; return res; &#125;&#125;","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"递归","slug":"递归","permalink":"http://www.congboss.top/tags/递归/"}]},{"title":"Unique Paths","slug":"Unique Paths","date":"2018-02-11T04:00:42.000Z","updated":"2018-03-27T05:48:27.700Z","comments":true,"path":"2018/02/11/Unique Paths/","link":"","permalink":"http://www.congboss.top/2018/02/11/Unique Paths/","excerpt":"","text":"A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there?123456789101112131415161718192021class Solution &#123; Map&lt;String,Integer&gt; cache=new HashMap&lt;&gt;(); public int uniquePaths(int m, int n) &#123; cache.clear();//记得加上 int ans=robot(m,n); return ans; &#125; public int robot(int x,int y) &#123; if(x==1||y==1) return 1; if(cache.containsKey(x+\",\"+y)) &#123; return cache.get(x+\",\"+y); &#125; int c=robot(x-1,y)+robot(x,y-1); cache.put(x+\",\"+y,c); return c; &#125;&#125;","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.congboss.top/tags/动态规划/"}]},{"title":"House Robber(打家劫舍)","slug":"House Robber","date":"2018-02-10T03:00:42.000Z","updated":"2019-05-12T09:38:00.905Z","comments":true,"path":"2018/02/10/House Robber/","link":"","permalink":"http://www.congboss.top/2018/02/10/House Robber/","excerpt":"","text":"You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.12345678910111213141516171819202122class Solution &#123; Map&lt;Integer,Integer&gt; cache=new HashMap&lt;&gt;(); public int robbot(int index,int [] nums) &#123; if(index&gt;=nums.length) return 0; if(cache.containsKey(index)) return cache.get(index); int a=nums[index]+robbot(index+2,nums); int b=0+robbot(index+1,nums); int c=Math.max(a,b); cache.put(index,c); return c; &#125; public int rob(int[] nums) &#123; cache.clear();//不要忘记写 if(nums.length==0) return 0; return robbot(0,nums); &#125;&#125;","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"Subsets","slug":"Subsets","date":"2018-02-08T04:00:42.000Z","updated":"2018-03-26T11:58:05.379Z","comments":true,"path":"2018/02/08/Subsets/","link":"","permalink":"http://www.congboss.top/2018/02/08/Subsets/","excerpt":"","text":"Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets.123456789101112131415161718class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125;","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"Combination Sum II(no duplicate numbers)","slug":"Combination Sum II(no duplicate numbers)","date":"2018-02-07T04:00:42.000Z","updated":"2018-03-26T08:10:29.664Z","comments":true,"path":"2018/02/07/Combination Sum II(no duplicate numbers)/","link":"","permalink":"http://www.congboss.top/2018/02/07/Combination Sum II(no duplicate numbers)/","excerpt":"","text":"Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.123456789101112131415161718192021class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(candidates); backtrack(list, new ArrayList&lt;&gt;(), candidates, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; if(i&gt;start&amp;&amp;(nums[i]==nums[i-1])) continue; tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i+1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125;&#125;","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"Combination Sum","slug":"Combination Sum","date":"2018-02-07T03:00:42.000Z","updated":"2018-03-26T07:40:40.631Z","comments":true,"path":"2018/02/07/Combination Sum/","link":"","permalink":"http://www.congboss.top/2018/02/07/Combination Sum/","excerpt":"","text":"Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times.1234567891011121314151617181920212223242526class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list=new ArrayList&lt;&gt;(); Arrays.sort(candidates); backTrack(list,new ArrayList&lt;&gt;(),candidates,target,0); return list; &#125; public void backTrack(List&lt;List&lt;Integer&gt;&gt; list,ArrayList&lt;Integer&gt; tempList,int [] nums,int remain,int start) &#123; if(remain&lt;0) return; else if(remain==0) &#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else &#123; for(int i=start;i&lt;nums.length;i++) &#123; tempList.add(nums[i]); backTrack(list,tempList,nums,remain-nums[i],i); tempList.remove(tempList.size()-1); &#125; &#125; &#125;&#125; TIPS：递归","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"全排列（可能含重复数字）","slug":"全排列（可能含重复数字）","date":"2018-02-06T03:00:42.000Z","updated":"2018-03-26T05:34:21.294Z","comments":true,"path":"2018/02/06/全排列（可能含重复数字）/","link":"","permalink":"http://www.congboss.top/2018/02/06/全排列（可能含重复数字）/","excerpt":"","text":"Given a collection of numbers that might contain duplicates, return all possible unique permutations.12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list=new ArrayList&lt;&gt;(); Arrays.sort(nums); backTrack(list,new ArrayList&lt;&gt;(),nums,new boolean [nums.length]); return list; &#125; public void backTrack(List&lt;List&lt;Integer&gt;&gt; list,List&lt;Integer&gt; tempList,int [] nums,boolean[] used) &#123; if(tempList.size()==nums.length) &#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else &#123; for(int i=0;i&lt;nums.length;i++) &#123; if(used[i]||(i&gt;0)&amp;&amp;(nums[i]==nums[i-1])&amp;&amp;(!used[i-1])) continue; used[i]=true; tempList.add(nums[i]); backTrack(list,tempList,nums,used); used[i]=false; tempList.remove(tempList.size()-1); &#125; &#125; &#125;&#125;","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"全排列","slug":"全排列","date":"2018-02-04T03:00:42.000Z","updated":"2018-03-26T02:23:28.767Z","comments":true,"path":"2018/02/04/全排列/","link":"","permalink":"http://www.congboss.top/2018/02/04/全排列/","excerpt":"","text":"Given a collection of distinct numbers, return all possible permutations.1234567891011121314151617181920212223242526class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list=new ArrayList&lt;&gt;(); backTrack(list,new LinkedList&lt;&gt;(),nums); return list; &#125; public void backTrack(List&lt;List&lt;Integer&gt;&gt; list,LinkedList &lt;Integer&gt; tempList,int [] nums) &#123; if(tempList.size()==nums.length) &#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else &#123; for(int i=0;i&lt;nums.length;i++) &#123; if(tempList.contains(nums[i])) continue; tempList.add(nums[i]); backTrack(list,tempList,nums); tempList.removeLast();//仔细些 &#125; &#125; &#125;&#125; TIPS：递归","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"链表划分","slug":"Partition List","date":"2018-01-15T03:00:42.000Z","updated":"2018-03-21T04:57:17.482Z","comments":true,"path":"2018/01/15/Partition List/","link":"","permalink":"http://www.congboss.top/2018/01/15/Partition List/","excerpt":"","text":"Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. For example,Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode partition(ListNode head, int x) &#123; if(head==null||head.next==null) return head; ListNode dummy1=new ListNode(0); ListNode dummy2=new ListNode(0); ListNode cur1=dummy1; ListNode cur2=dummy2; while(head!=null) &#123; if(head.val&lt;x) &#123; cur1.next=head; cur1=head; &#125; else &#123; cur2.next=head; cur2=head; &#125; head=head.next; &#125; cur2.next=null; cur1.next=dummy2.next; return dummy1.next; &#125;&#125; TIPS:使用两个链表求解~","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"数据库常见笔试面试题详解","slug":"数据库常见笔试面试题详解","date":"2018-01-13T11:00:42.000Z","updated":"2018-03-22T06:42:00.686Z","comments":true,"path":"2018/01/13/数据库常见笔试面试题详解/","link":"","permalink":"http://www.congboss.top/2018/01/13/数据库常见笔试面试题详解/","excerpt":"（一）什么是存储过程？有哪些优缺点？什么是存储过程：存储过程可以说是一个记录集吧，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。","text":"（一）什么是存储过程？有哪些优缺点？什么是存储过程：存储过程可以说是一个记录集吧，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。 存储过程的好处： 1.由于数据库执行动作时，是先编译后执行的。然而存储过程是一个编译过的代码块，所以执行效率要比T-SQL语句高。 2.一个存储过程在程序在网络中交互时可以替代大堆的T-SQL语句，所以也能降低网络的通信量，提高通信速率。 3.通过存储过程能够使没有权限的用户在控制之下间接地存取数据库，从而确保数据的安全。 （二）索引是什么？有什么作用以及优缺点？索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构 你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。 MySQL数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引 索引加快数据库的检索速度 索引降低了插入、删除、修改等维护任务的速度 唯一索引可以确保每一行数据的唯一性 通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能 索引需要占物理和数据空间 数据库索引详细教程：https://kb.cnblogs.com/page/45712/ （三）什么是事务？事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。事务更详细的教程：http://blog.csdn.net/zdwzzu2006/article/details/5947062 （四）数据库的乐观锁和悲观锁是什么？数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。 乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 深入理解悲观锁和乐观锁：http://www.open-open.com/lib/view/open1452046967245.html （五） 使用索引查询一定能提高查询的性能吗？为什么通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价. 索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改.这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O.因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况: 基于一个范围的检索,一般查询返回结果集小于表中记录数的30% 基于非唯一性索引的检索 （六）简单说一说drop、delete与truncate的区别SQL中的drop、delete、truncate都表示删除，但是三者有一些差别 delete和truncate只删除表的数据不删除表的结构速度,一般来说: drop&gt; truncate &gt;deletedelete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger. 进一步了解drop、delete、truncate：http://blog.csdn.net/ws0513/article/details/49980547 （七）drop、delete与truncate分别在什么场景之下使用？ 不再需要一张表的时候，用drop 想删除部分数据行时候，用delete，并且带上where子句 保留表而删除所有数据的时候用truncate （八） 超键、候选键、主键、外键分别是什么？超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。 候选键：是最小超键，即没有冗余元素的超键。 主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。 外键：在一个表中存在的另一个表的主键称此表的外键。 （九）什么是视图？以及视图的使用场景有哪些？视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。 只暴露部分字段给访问者，所以就建一个虚表，就是视图。 查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异 （十）说一说三个范式第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。 第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。 第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段x → 非关键字段y 进一步了解三范式：https://www.zhihu.com/question/24696366 （十一）绘制ER图自己理解。","raw":null,"content":null,"categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.congboss.top/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.congboss.top/tags/数据库/"}]},{"title":"数据库三大范式","slug":"数据库三大范式","date":"2018-01-12T11:00:42.000Z","updated":"2018-08-05T15:23:57.832Z","comments":true,"path":"2018/01/12/数据库三大范式/","link":"","permalink":"http://www.congboss.top/2018/01/12/数据库三大范式/","excerpt":"第一范式\n第一范式（1NF）要求数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值。\n若某一列有多个值，可以将该列单独拆分成一个实体，新实体和原实体间是一对多的关系。\n在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。\n","text":"第一范式 第一范式（1NF）要求数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值。 若某一列有多个值，可以将该列单独拆分成一个实体，新实体和原实体间是一对多的关系。 在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。 第二范式 满足第二范式（2NF）必须先满足第一范式（1NF）。 第二范式要求实体中每一行的所有非主属性都必须完全依赖于主键；即：非主属性必须完全依赖于主键。 完全依赖：主键可能由多个属性构成，完全依赖要求不允许存在非主属性依赖于主键中的某一部分属性。 若存在哪个非主属性依赖于主键中的一部分属性，那么要将发生部分依赖的这一组属性单独新建一个实体，并且在旧实体中用外键与新实体关联，并且新实体与旧实体间是一对多的关系。第三范式 满足第三范式必须先满足第二范式。 第三范式要求：实体中的属性不能是其他实体中的非主属性。因为这样会出现冗余。即：属性不依赖于其他非主属性。 如果一个实体中出现其他实体的非主属性，可以将这两个实体用外键关联，而不是将另一张表的非主属性直接写在当前表中，通俗来讲也就是说如果有一个非主属性A依赖于主属性，而另一个非主属性B依赖与非主属性A，那么也就是说存在B对于主属性的传递函数依赖，这样显然是不满足与3NF的。 关于数据库三范式比较优秀的讲解：https://www.zhihu.com/question/24696366","raw":null,"content":null,"categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.congboss.top/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.congboss.top/tags/数据库/"}]},{"title":"Reverse Linked List II","slug":"翻转链表(二)","date":"2018-01-12T03:00:42.000Z","updated":"2018-03-21T02:45:26.775Z","comments":true,"path":"2018/01/12/翻转链表(二)/","link":"","permalink":"http://www.congboss.top/2018/01/12/翻转链表(二)/","excerpt":"","text":"Reverse a linked list from position m to n. Do it in-place and in one-pass. For example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4, return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. Note:Given m, n satisfy the following condition:1 ≤ m ≤ n ≤ length of list.123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseBetween(ListNode head, int m, int n) &#123; if(m==n || head==null) return head; ListNode dummy=new ListNode(0); dummy.next=head; ListNode pre=dummy; for(int i=0;i&lt;m-1;i++) &#123; pre=pre.next; &#125; ListNode start=pre.next; ListNode then=start.next; for(int i=0;i&lt;n-m;i++) &#123; start.next = then.next; then.next = prev.next; prev.next = then; then = start.next; &#125; return dummy.next; &#125;&#125; TIPS：画图，判断条件时要注意~","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"数据库事务详解","slug":"数据库事务详解","date":"2018-01-11T11:00:42.000Z","updated":"2018-03-20T12:47:34.870Z","comments":true,"path":"2018/01/11/数据库事务详解/","link":"","permalink":"http://www.congboss.top/2018/01/11/数据库事务详解/","excerpt":"什么是『事务』？事务就是一组具有原子性的操作，这一组操作要么全都正确执行，要么全都不执行。事务能保证数据库从一种一致性状态转换为另一种一致性状态。","text":"什么是『事务』？事务就是一组具有原子性的操作，这一组操作要么全都正确执行，要么全都不执行。事务能保证数据库从一种一致性状态转换为另一种一致性状态。 事务的四大特性ACID 原子性 原子性指的是事务是一个不可分割的操作，要么全都正确执行，要么全都不执行。 一致性 事务开始前和事务结束后，数据库的完整性约束没有被破坏。 隔离性 事务的执行是相互独立的，它们不会相互干扰，一个事务不会看到另一个正在运行过程中的事务的数据。 持久性 事务结束后，事务的结果必须是永久保存的。即使数据库发生崩溃，在数据库恢复后事务提交的结果仍然不会丢失。PS：事务只能保证数据库的高可靠性，即数据库本身发生问题后，事务提交后的数据仍然能恢复；而如果不是数据库本身的故障，如硬盘损坏了，那么事务提交的数据可能就丢失了。这属于『高可用性』的范畴。因此，事务只能保证数据库的『高可靠性』，而『高可用性』需要整个系统共同配合实现。 事务的分类 扁平事务 它是实际生产环境中最常用、最简单的事务类型。 事务从BEGIN WORK开始，从COMMIT WORK或ROLLBACK WORK结束。 缺点：发生错误时回滚到事务的起始位置，无法回滚部分操作。而回滚所有的操作开销太大。 带有保存点的扁平事务 这种事务能设置多个保存点，当发生错误时可以回滚到事务中指定的保存点，而不需要将整个事务回滚。 链事务 嵌套事务 分布式事务 数据库并发访问会出现的问题 更新丢失 当有两个并发执行的事务，更新同一行数据，那么有可能一个事务会把另一个事务的更新覆盖掉。当数据库没有加任何锁操作的情况下会发生。 脏读 一个事务读到另一个尚未提交的事务中的数据。该数据可能会被回滚从而失效。如果第一个事务拿着失效的数据去处理那就发生错误了。 不可重复读不可重复度的含义：一个事务对同一行数据读了两次，却得到了不同的结果。它具体分为如下两种情况：1. 虚读：在事务1两次读取同一记录的过程中，事务2对该记录进行了修改，从而事务1第二次读到了不一样的记录。2. 幻读：事务1在两次查询的过程中，事务2对该表进行了插入、删除操作，从而事务1第二次查询的结果发生了变化。 与『脏读』的区别？ 脏读读到的是尚未提交的数据，而不可重复读读到的是已经提交的数据，只不过在两次读的过程中数据被另一个事务改过了。 事务的隔离级别数据库事务的隔离级别有4个，由低到高依次为Read uncommitted 、Read committed 、Repeatable read 、Serializable ，这四个级别可以逐个解决脏读 、不可重复读 、幻读 这几类问题。 Read uncommitted 读未提交 在该级别下，一个事务对一行数据修改的过程中，不允许另一个事务对该行数据进行修改，但允许另一个事务对该行数据读。因此本级别下，不会出现更新丢失，但会出现脏读、不可重复读。 Read committed 读提交 在该级别下，未提交的写事务不允许其他事务访问该行，因此不会出现脏读；但是读取数据的事务允许其他事务的访问该行数据，因此会出现不可重复读的情况。 Repeatable read 重复读 在该级别下，读事务禁止写事务，但允许读事务，因此不会出现同一事务两次读到不同的数据的情况（不可重复读），且写事务禁止其他一切事务。 Serializable 序列化 该级别要求所有事务都必须串行执行，因此能避免一切因并发引起的问题，但效率很低。 隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。 使用事务的注意事项 不要在循环中提交事务 不要使用自动提交 不要使用自动回滚 不要使用长事务","raw":null,"content":null,"categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.congboss.top/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.congboss.top/tags/数据库/"}]},{"title":"数据库索引全面分析","slug":"数据库索引解析","date":"2018-01-10T11:00:42.000Z","updated":"2018-03-22T05:57:26.585Z","comments":true,"path":"2018/01/10/数据库索引解析/","link":"","permalink":"http://www.congboss.top/2018/01/10/数据库索引解析/","excerpt":"索引是什么？数据库中查找操作非常普遍，索引就是提升查找速度的一种手段。","text":"索引是什么？数据库中查找操作非常普遍，索引就是提升查找速度的一种手段。 索引分类1.B+树索引它就是传统意义上的索引，它是最常用、最有效的索引。 2.哈希索引哈希索引是一种自适应的索引，数据库会根据表的使用情况自动生成哈希索引，我们人为是没办法干预的。 3.全文索引用于实现关键词搜索。但它只能根据空格分词，因此不支持中文。若要实现搜索功能，可选择lucene。 4.RTree索引在mysql很少使用，仅支持geometry数据类型；相对于BTREE，RTREE的优势在于范围查找。 B+树索引数据库以页为存储单元，一个页是8K（8192Byte），一页可以存放N条记录。页在B+树中分为：数据页和索引页。B+树的高一般为2-4层，因此查找某一键值的行记录只需2-4次IO，效率较高。 聚集索引 和 非聚集索引不管是聚集索引还是非聚集索引，它们的逻辑结构都一棵是B+树，它们的唯一区别在于： 聚集索引的数据页存放的是完整的记录；也就是说，聚集索引决定了表的物理存储顺序； 非聚集索引的数据页只存指向记录的地址信息，它真正的数据已经在聚集索引中存储了。 联合索引 和 覆盖索引1.联合索引当查询条件涉及多列时，可以使用联合索引。 2.覆盖索引只需通过辅助索引就能获取要查询的信息，而无需再次通过聚集索引查询具体的记录信息。由于覆盖索引并不包含整行的记录，因此它的大小远远小于聚集索引。它比较适合做一些统计操作。 MyISAM索引实现1.主键索引在主键索引中，索引页中存放的是主键和指向数据页的偏移量；数据页中存放的是主键和该主键所属行记录的地址空间。 2.辅助索引在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。 综上所述，在MyISAM中，索引文件和数据文件分开存放，不管是主键索引还是辅助索引，都属于非聚集索引。 InnoDB索引实现1.主键索引索引页仍然存放主键和和指向数据页的偏移量，但数据页存放的是完整的记录。也就是在InnoDB中，数据和主键索引是存放在一起的。 2.辅助索引索引节点存放的内容一样，仍然是键值信息和指向数据页的偏移量；但数据页中存放的是键值信息和该键值对应的主键。然后通过主键查询主键索引就能找到该条记录。 综上所述： 聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。 InnoDB的辅助索引也会包含主键列，所以，如果主键定义的比较大，其他索引也将很大。如果想在表上定义 、很多索引，则争取尽量把主键定义得小一些。InnoDB 不会压缩索引。 索引的优点 第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 索引的缺点 第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。哪些情况需要加索引？ 在经常需要搜索的列上，可以加快搜索的速度； 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构； 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度； 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的； 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。哪些情况不需要加索引？ 第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。","raw":null,"content":null,"categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.congboss.top/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.congboss.top/tags/数据库/"}]},{"title":"http1.0与http1.1区别","slug":"http1.0与http1.1区别","date":"2018-01-10T06:49:23.000Z","updated":"2018-08-04T17:38:42.595Z","comments":true,"path":"2018/01/10/http1.0与http1.1区别/","link":"","permalink":"http://www.congboss.top/2018/01/10/http1.0与http1.1区别/","excerpt":"翻了下HTTP1.1的协议标准RFC2616，下面是看到的一些它跟HTTP1.0的差别。\n\nPersistent Connection持久连接在HTTP1.0中，每对Request/Response都使用一个新的连接。\nHTTP 1.1则支持持久连接Persistent Connection, 并且默认使用persistent  connection. 在同一个tcp的连接中可以传送多个HTTP请求和响应. 多个请求和响应可以重叠，多个请求和响应可以同时进行. 更加多的请求头和响应头(比如HTTP1.0没有host的字段).\n\n\nHTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。","text":"翻了下HTTP1.1的协议标准RFC2616，下面是看到的一些它跟HTTP1.0的差别。 Persistent Connection持久连接在HTTP1.0中，每对Request/Response都使用一个新的连接。 HTTP 1.1则支持持久连接Persistent Connection, 并且默认使用persistent connection. 在同一个tcp的连接中可以传送多个HTTP请求和响应. 多个请求和响应可以重叠，多个请求和响应可以同时进行. 更加多的请求头和响应头(比如HTTP1.0没有host的字段). HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。 HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。此外，由于大多数网页的流量都比较小，一次TCP连接很少能通过slow-start区，不利于提高带宽利用率。 在1.0时的会话方式： 建立连接 发出请求信息 回送响应信息 关掉连接 小结:浏览器和web服务器连接很短，每次连接只处理一个请求和响应。对每一个页的请求,浏览器与web服务器都要建立一次单独的连接.浏览器没有 关掉前,连接就断开了.浏览器和服务器之间的通信是完全独立分开的请求和响应对.因为这样没法断点浏览器是否断开,没法做连接状态控制。建立和关掉连接会很占用连接时间. 在一个网页中,在http头中的Connection中有多少个close的头,就相当有多少个http的连接. HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。例如：一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。 HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。 在HTTP/1.0中，要建立长连接，可以在请求消息中包含Connection: Keep-Alive头域，如果服务器愿意维持这条连接，在响应消息中也会包含一个Connection: Keep-Alive的头域。同时，可以加入一些指令描述该长连接的属性，如max，timeout等。 事实上，Connection头域可以携带三种不同类型的符号： 1、一个包含若干个头域名的列表，声明仅限于一次hop连接的头域信息； 2、任意值，本次连接的非标准选项，如Keep-Alive等； 3、close值，表示消息传送完成之后关闭长连接； 客户端和源服务器之间的消息传递可能要经过很多中间节点的转发，这是一种逐跳传递（hop-by-hop）。HTTP/1.1相应地引入了hop-by-hop头域，这种头域仅作用于一次hop，而非整个传递路径。每一个中间节点（如Proxy，Gateway）接收到的消息中如果包含Connection头域，会查找Connection头域中的一个头域名列表，并在将消息转发给下一个节点之前先删除消息中这些头域。 通常，HTTP/1.0的Proxy不支持Connection头域，为了不让它们转发可能误导接收者的头域，协议规定所有出现在Connection头域中的头域名都将被忽略。 Host域在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。 HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。此外，服务器应该接受以绝对路径标记的资源请求。 HTTP1.1在Request消息头里头多了一个Host域，比如： GET /pub/WWW/TheProject.html HTTP/1.1 Host: www.w3.org HTTP1.0则没有这个域。可能HTTP1.0的时候认为，建立TCP连接的时候已经指定了IP地址，这个IP地址上只有一个host。 由于HTTP 1.0不支持Host请求头字段，WEB浏览器无法使用主机头名来明确表示要访问服务器上的哪个WEB站点，这样就无法使用WEB服务器在同一个IP地址和端口号上配置多个虚拟WEB站点。在HTTP 1.1中增加Host请求头字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。 date/timestamp (日期时间戳)(接收方向) 无论是HTTP1.0还是HTTP1.1，都要能解析下面三种date/time stamp： Sun, 06 Nov 1994 08:49:37GMT ; RFC 822, updated by RFC 1123 Sunday, 06-Nov-94 08:49:37GMT ; RFC 850, obsoleted by RFC 1036 Sun Nov 6 08:49:371994 ; ANSI C&apos;s asctime() format (发送方向) HTTP1.0要求不能生成第三种asctime格式的date/time stamp； HTTP1.1则要求只生成RFC 1123(第一种)格式的date/time stamp Transfer CodingsHTTP1.1支持chunked transfer，所以可以有Transfer-Encoding头部域: Transfer-Encoding:chunked HTTP1.0则没有。 HTTP消息中可以包含任意长度的实体，通常它们使用Content-Length来给出消息结束标志。但是，对于很多动态产生的响应，只能通过缓冲完整的消息来判断消息的大小，但这样做会加大延迟。如果不使用长连接，还可以通过连接关闭的信号来判定一个消息的结束。 HTTP/1.1中引入了Chunked transfer-coding来解决上面这个问题，发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。 在HTTP/1.0中，有一个Content-MD5的头域，要计算这个头域需要发送方缓冲完整个消息后才能进行。而HTTP/1.1中，采用chunked分块传递的消息在最后一个块（零长度）结束之后会再传递一个拖尾（trailer），它包含一个或多个头域，这些头域是发送方在传递完所有块之后再计算出值的。发送方会在消息中包含一个Trailer头域告诉接收方这个拖尾的存在。 Quality ValuesHTTP1.1多了个qvalue域： 123qvalue = ( \"0\" [\".\" 0*3DIGIT ] ) | ( \"1\" [ \".\" 0*3(\"0\") ] ) Entity Tags用于Cache。 Range 和 Content-Range(节约优化)HTTP1.1支持传送内容的一部分。比方说，当客户端已经有内容的一部分，为了节省带宽，可以只向服务器请求一部分。 HTTP/1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了。例如，客户端只需要显示一个文档的部分内容，又比如下载大文件时需要支持断点续传功能，而不是在发生断连后不得不重新下载完整的包。 HTTP/1.1中在请求消息中引入了range头域，它允许只请求资源的某个部分。在响应消息中Content-Range头域声明了返回的这部分对象的偏移值和长度。如果服务器相应地返回了对象所请求范围的内容，则响应码为206（Partial Content），它可以防止Cache将响应误以为是完整的一个对象。 节省带宽资源的一个非常有效的做法就是压缩要传送的数据。Content-Encoding是对消息进行端到端（end-to-end）的编码，它可能是资源在服务器上保存的固有格式（如jpeg图片格式）；在请求消息中加入Accept-Encoding头域，它可以告诉服务器客户端能够解码的编码方式。 而Transfer-Encoding是逐段式（hop-by-hop）的编码，如Chunked编码。在请求消息中加入TE头域用来告诉服务器能够接收的transfer-coding方式. 100(Continue) Status(节约带宽)另外一种浪费带宽的情况是请求消息中如果包含比较大的实体内容，但不确定服务器是否能够接收该请求（如是否有权限），此时若贸然发出带实体的请求，如果被拒绝也会浪费带宽。 HTTP/1.1加入了一个新的状态码100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。注意，HTTP/1.0的客户端不支持100响应码。但可以让客户端在请求消息中加入Expect头域，并将它的值设置为100-continue。 100 (Continue) 状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。 客户端在Request头部中包含 Expect: 100-continue Server看到之后呢如果回100 (Continue) 这个状态代码，客户端就继续发requestbody。 这个是HTTP1.1才有的。 Request methodHTTP1.1增加了OPTIONS,PUT, DELETE, TRACE, CONNECT这些Request方法. 12345678910111213141516171819Method =&quot;OPTIONS&quot; ;Section 9.2 |&quot;GET&quot; ; Section 9.3 |&quot;HEAD&quot; ; Section 9.4 |&quot;POST&quot; ; Section 9.5 ** | &quot;PUT&quot; ;Section 9.6** **| &quot;DELETE&quot; ;Section 9.7 |&quot;TRACE&quot; ; Section 9.8 | &quot;CONNECT&quot; ;Section 9.9** | extension-method extension-method =token Status codeHTTP1.1 增加的新的status code： (HTTP1.0没有定义任何具体的1xx status code, HTTP1.1有2个) 100 Continue 101 Switching Protocols 203 Non-Authoritative Information 205 Reset Content 206 Partial Content 302 Found (在HTTP1.0中有个 302 Moved Temporarily) 303 See Other 305 Use Proxy 307 Temporary Redirect 405 Method Not Allowed 406 Not Acceptable 407 Proxy Authentication Required 408 Request Timeout 409 Conflict 410 Gone 411 Length Required 412 Precondition Failed 413 Request Entity Too Large 414 Request-URI Too Long 415 Unsupported Media Type 416 Requested Range Not Satisfiable 417 Expectation Failed 504 Gateway Timeout 505 HTTP Version Not Supported Cache (缓存)在HTTP/1.0中，使用Expire头域来判断资源的fresh或stale，并使用条件请求（conditional request）来判断资源是否仍有效。例如，cache服务器通过If-Modified-Since头域向服务器验证资源的Last-Modefied头域是否有更新，源服务器可能返回304（Not Modified），则表明该对象仍有效；也可能返回200（OK）替换请求的Cache对象。 此外，HTTP/1.0中还定义了Pragma:no-cache头域，客户端使用该头域说明请求资源不能从cache中获取，而必须回源获取。 HTTP/1.1在1.0的基础上加入了一些cache的新特性，当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活（revalidation）。 HTTP/1.0中，If-Modified-Since头域使用的是绝对时间戳，精确到秒，但使用绝对时间会带来不同机器上的时钟同步问题。而HTTP/1.1中引入了一个ETag头域用于重激活机制，它的值entity tag可以用来唯一的描述一个资源。请求消息中可以使用If-None-Match头域来匹配资源的entitytag是否有变化。 为了使caching机制更加灵活，HTTP/1.1增加了Cache-Control头域（请求消息和响应消息都可使用），它支持一个可扩展的指令子集：例如max-age指令支持相对时间戳；private和no-store指令禁止对象被缓存；no-transform阻止Proxy进行任何改变响应的行为。 Cache使用关键字索引在磁盘中缓存的对象，在HTTP/1.0中使用资源的URL作为关键字。但可能存在不同的资源基于同一个URL的情况，要区别它们还需要客户端提供更多的信息，如Accept-Language和Accept-Charset头域。为了支持这种内容协商机制(content negotiation mechanism)，HTTP/1.1在响应消息中引入了Vary头域，该头域列出了请求消息中需要包含哪些头域用于内容协商。 依据： rfc2616Hypertext Transfer Protocol – HTTP-1.1.txt rfc1945Hypertext Transfer Protocol – HTTP 1.0.txt 求消息中需要包含哪些头域用于内容协商。HTTP 1.1持久连接的好处 一个WEB站点每天可能要接收到上百万的用户请求，为了提高系统的效率，HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。但是，这也造成了一些性能上的缺陷，例如，一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的URL地址，当WEB浏览器访问这个网页文件时，浏览器首先要发出针对该网页文件的请求，当浏览器解析WEB服务器返回的该网页文档中的HTML内容时，发现其中的图像标签后，浏览器将根据标签中的src属性所指定的URL地址再次向服务器发出下载图像数据的请求，如图所示。 显然，访问一个包含有许多图像的网页文件的整个过程包含了多次请求和响应，每次请求和响应都需要建立一个单独的连接，每次连接只是传输一个文档和图像，上一 次和下一次请求完全分离。即使图像文件都很小，但是客户端和服务器端每次建立和关闭连接却是一个相对比较费时的过程，并且会严重影响客户机和服务器的性 能。当一个网页文件中包含Applet，JavaScript文件，CSS文件等内容时，也会出现类似上述的情况。 为了克服HTTP 1.0的这个缺陷，HTTP1.1支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。基于HTTP 1.1协议的客户机与服务器的信息交换过程，如图3.4所示。 可见，HTTP 1.1在继承了HTTP 1.0优点的基础上，也克服了HTTP 1.0的性能问题。不仅如此，HTTP 1.1还通过增加更多的请求头和响应头来改进和扩充HTTP1.0的功能。例如，由于HTTP 1.0不支持Host请求头字段，WEB浏览器无法使用主机头名来明确表示要访问服务器上的哪个WEB站点，这样就无法使用WEB服务器在同一个IP地址和端口号上配置多个虚拟WEB站点。在HTTP 1.1中增加Host请求头字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。","raw":null,"content":null,"categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.congboss.top/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.congboss.top/tags/计算机网络/"}]},{"title":"HTTP-请求、响应、缓存","slug":"HTTP-请求、响应、缓存","date":"2018-01-05T06:49:23.000Z","updated":"2018-08-04T17:17:06.655Z","comments":true,"path":"2018/01/05/HTTP-请求、响应、缓存/","link":"","permalink":"http://www.congboss.top/2018/01/05/HTTP-请求、响应、缓存/","excerpt":"\nHTTP请求格式做过Socket编程的人都知道，当我们设计一个通信协议时，“消息头/消息体”的分割方式是很常用的，消息头告诉对方这个消息是干什么的，消息体告诉对方怎么干。HTTP协议传输的消息也是这样规定的，每一个HTTP包都分为HTTP头和HTTP体两部分，消息体是可选的，而消息头是必须的。每当我们打开一个网页，在上面点击右键，选择“查看源文件”，这时看到的HTML代码就是HTTP的消息体，那么消息头可以通过浏览器的开发工具或者插件可以看到，如果火狐的Firebug，IE的Httpwatch。","text":"HTTP请求格式做过Socket编程的人都知道，当我们设计一个通信协议时，“消息头/消息体”的分割方式是很常用的，消息头告诉对方这个消息是干什么的，消息体告诉对方怎么干。HTTP协议传输的消息也是这样规定的，每一个HTTP包都分为HTTP头和HTTP体两部分，消息体是可选的，而消息头是必须的。每当我们打开一个网页，在上面点击右键，选择“查看源文件”，这时看到的HTML代码就是HTTP的消息体，那么消息头可以通过浏览器的开发工具或者插件可以看到，如果火狐的Firebug，IE的Httpwatch。 客户端通过发送 HTTP 请求向服务器请求对资源的访问。 它向服务器传递了一个数据块，也就是请求信息，HTTP 请求由三部分组成：请求行、 请求头和请求正文。 请求行：请求方法 URI 协议/版本 请求头(Request Header) 请求正文 下面是一个HTTP请求的数据：123456789101112POST /index.php HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-cn,zh;q=0.5Accept-Encoding: gzip, deflateConnection: keep-aliveReferer: http://localhost/Content-Length：25Content-Type：application/x-www-form-urlencoded username=aa&amp;password=1234 1、请求行：请求方法URI协议/版本请求的第一行是“方法 URL 协议/版本”，并以 回车换行作为结尾。请求行以空格分隔。格式如下：POST /index.php HTTP/1.1以上代码中“GET”代表请求方法，“//ndex.php”表示URI，“HTTP/1.1代表协议和协议的版本。根据HTTP标准，HTTP请求可以使用多种请求方法。例如：HTTP1.1支持7种请求方法：GET、POST、HEAD、OPTIONS、PUT、DELETE和TARCE。在Internet应用中，最常用的方法是GET和POST。URL完整地指定了要访问的网络资源，通常只要给出相对于服务器的根目录的相对目录即可，因此总是以“/”开头，最后，协议版本声明了通信过程中使用HTTP的版本。 请求方法在 HTTP 协议中，HTTP 请求可以使用多种请求方法，这些方法指明了要以何种方式来访问 Request-URI 所标识的资源。HTTP1.1 支持的请求方法如下表所示： HTTP1.1 中的请求方式： 重点介绍 GET、POST 和 HEAD 三个方法： （1）GET GET 方法用于获取由 Request-URI 所标识的资源的信息，常见的形式是： GET Request-URI HTTP/1.1 GET方法是默认的HTTP请求方法，例如当我们通过在浏览器的地址栏中直接输入网址的方式去访问网页的时候，浏览器采用的就是 GET 方法向服务器获取资源。 我们可以使用GET方法来提交表单数据，用GET方法提交的表单数据只经过了简单的编码，同时它将作为URL的一部分向服务器发送，因此，如果使用GET方法来提交表单数据就存在着安全隐患上。例如： Http://localhost/login.php?username=aa&amp;password=1234 从上面的URL请求中，很容易就可以辩认出表单提交的内容。（？之后的内容）另外由于GET方法提交的数据是作为URL请求的一部分所以提交的数据量不能太大。这是因为浏览器对url的长度有限制 各种浏览器也会对url的长度有所限制，下面是几种常见浏览器的url长度限制:(单位:字符) IE : 2803Firefox:65536Chrome:8182Safari:80000Opera:190000（2）POST POST方法是GET方法的一个替代方法，它主要是向Web服务器提交表单数据，尤其是大批量的数据。 在请求头信息结束之后的两个回车换行之后（实际是空一行），就是表单提交的数据。如上面提到的post表单数据： username=aa&amp;password=1234 POST方法克服了GET方法的一些缺点。通过POST方法提交表单数据时，数据不是作为URL请求的一部分而是作为标准数据传送给Web服务器，这就克服了GET方法中的信息无法保密和数据量太小的缺点。因此，出于安全的考虑以及对用户隐私的尊重，通常表单提交时采用POST方法。 从编程的角度来讲，如果用户通过GET方法提交数据，则数据存放在QUERY＿STRING环境变量中，而POST方法提交的数据则可以从标准输入流中获取。 GET与POST方法有以下区别： 1、在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放在HTTP包的body中。 2、GET方式提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST则没有此限制。 3、安全性问题。正如在（1）中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好。4、服务器取值方式不一样。GET方式取值，如php可以使用$_GET来取得变量的值，而POST方式通过$_POST来获取变量的值。 （3）HEAD HEAD 方法与 GET 方法几乎是相同的，它们的区别在于 HEAD 方法只是请求消息报头，而不是完整的内容。对于 HEAD 请求的回应部分来说，它的 HTTP 头部中包含的信息与通过 GET 请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到 Request-URI 所标识的资源的信息。这个方法通常被用于测试超链接的有效性，是否可以访问，以及最近是否更新。 要注意的是，在 HTML 文档中，书写 get 和 post，大小写都可以，但在 HTTP 协议中的 GET 和 POST 只能是大写形式。 请求头 每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。 HTTP最常见的请求头如下： Transport 头域 Connection： 作用：表示是否需要持久连接。 如果服务器看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接）,它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，服务器需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入 ByteArrayOutputStream，然后在正式写出内容之前计算它的大小； 例如： Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的 网页，会继续使用这一条已经建立的连接 例如： Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。 Host（发送请求时，该报头域是必需的） Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。 eg：http://；localhost/index.html浏览器发送的请求消息中，就会包含Host请求报头域，如下：Host：localhost 此处使用缺省端口号80，若指定了端口号8080，则变成：Host：localhost:8080 Client 头域 Accept： 作用：浏览器可以接受的媒体类型（MIME类型）, 例如： Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的html文档, 如果服务器无法返回text/html类型的数据，服务器应该返回一个406错误(non acceptable)。 通配符 代表任意类型。例如 Accept: /* 代表浏览器可以处理所有类型，(一般浏览器发给服务器都是发这个) Accept-Encoding： 作用： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）; 例如： Accept-Encoding: gzip, deflate。Server能够向支持gzip/deflate的浏览器返回经gzip或者deflate编码的HTML页面。 许多情形下这可以减少5到10倍的下载时间，也节省带宽。 Accept-Language： 作用： 浏览器申明自己接收的语言。 语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等； 例如： Accept-Language:zh-cn 。如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。 User-Agent： 作用：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本. 我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上， 服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。 例如： User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E) Accept-Charset： 作用：浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）； 例如：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。 Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中； Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。 Cookie/Login 头域 Cookie: 作用： 最重要的header, 将cookie的值发送给HTTP 服务器 Entity头域 Content-Length 作用：发送给HTTP服务器数据的长度。即请求消息正文的长度； 例如： Content-Length: 38 Content-Type： 作用： 例如：Content-Type: application/x-www-form-urlencoded Miscellaneous 头域 Referer: 作用： 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里， 他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问 他的网站。 例如: Referer:http://translate.google.cn/?hl=zh-cn&amp;tab=wT Cache 头域 If-Modified-Since： 作用： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中。 例如：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT。 If-None-Match： 作用: If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能 例如: If-None-Match: “03f2b33c0bfcc1:0” Pragma： 作用： 防止页面被缓存， 在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样 Pargma只有一个用法， 例如： Pragma: no-cache 注意: 在HTTP/1.0版本中，只实现了Pragema:no-cache, 没有实现Cache-Control Cache-Control： 作用: 这个是非常重要的规则。 这个用来指定Response-Request遵循的缓存机制。各个指令含义如下 Cache-Control:Public 可以被任何缓存所缓存（） Cache-Control:Private 内容只缓存到私有缓存中 Cache-Control:no-cache 所有内容都不会被缓存 HTTP响应格式 在接收和解释请求消息后，服务器会返回一个 HTTP 响应消息。与 HTTP 请求类似，HTTP 响应也是由三个部分组成，分别是：状态行、消息报头和响应正文。如：1234567891011HTTP/1.1 200 OK Date: Sun, 17 Mar 2013 08:12:54 GMT Server: Apache/2.2.8 (Win32) PHP/5.2.5 X-Powered-By: PHP/5.2.5 Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/ Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0 Pragma: no-cache Content-Length: 4393 Keep-Alive: timeout=5, max=100 Connection: Keep-Alive Content-Type: text/html; charset=utf-8&lt;html&gt; &lt;head&gt; &lt;title&gt;HTTP响应示例&lt;title&gt; &lt;/head&gt; &lt;body&gt; Hello HTTP! &lt;/body&gt; &lt;/html&gt; 1、状态行 状态行由协议版本、数字形式的状态代码，及相应的状态描述组成，各元素之间以空格分隔，结尾时回车换行符，格式如下： HTTP-Version Status-Code Reason-Phrase CRLF HTTP-Version 表示服务器 HTTP 协议的版本，Status-Code 表示服务器发回的响应代码，Reason-Phrase 表示状态代码的文本描述，CRLF 表示回车换行。例如： HTTP/1.1 200 OK (CRLF) 状态代码与状态描述 状态代码由 3 位数字组成， 表示请求是否被理解或被满足，状态描述给出了关于状态码的简短的文字描述。状态码的第一个数字定义了响应类别，后面两位数字没有具体分类。第一个数字有 5 种取值，如下所示。 1xx：指示信息——表示请求已经接受，继续处理 2xx：成功——表示请求已经被成功接收、理解、接受。 3xx：重定向——要完成请求必须进行更进一步的操作 4xx：客户端错误——客户端请求有错误或请求无法实现 5xx：服务器端错误——服务器未能实现合法的请求。常见状态代码、状态描述、说明：200 OK //客户端请求成功 303：重定向，即从原url重定向到新的url。 例如php 的hear函数header（”localtion:/index.php”） 400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden //服务器收到请求，但是拒绝提供服务，一般是服务器路径没有权限或者是其他权限相关问题404 Not Found //请求资源不存在，eg：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误：一般来说，这个问题都会在服务器端的源代码出现错误时出现，比如出现死循环。 502 Bad Gateway//作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。比如LNMP ,php-fpm没有启动就会报502错误。 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常，比如java 容器部署war的时候，就出现503, 或者是nginx处理的文件没有权限。 504 Gateway Time-out：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应，比如nginx和php-fpm， php设置sleep（200），就会收到504 Gateway Time-out。注意：某些代理服务器在DNS查询超时时会返回400或者500错误 2、响应正文响应正文就是服务器返回的资源的内容，响应头和正文之间也必须用空行分隔。如：12345678&lt;html&gt;&lt;head&gt;&lt;title&gt;HTTP响应示例&lt;title&gt;&lt;/head&gt;&lt;body&gt;Hello HTTP!&lt;/body&gt;&lt;/html&gt; 3 、响应头信息HTTP最常见的响应头如下所示： Cache头域 Date： 作用：生成消息的具体时间和日期，即当前的GMT时间。 例如： Date: Sun, 17 Mar 2013 08:12:54 GMT Expires： 作用: 浏览器会在指定过期时间内使用本地缓存，指明应该在什么时候认为文档已经过期，从而不再缓存它。 例如: Expires: Thu, 19 Nov 1981 08:52:00 GMT Vary 作用： 例如: Vary: Accept-Encoding Cookie/Login 头域 P3P 作用: 用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题 例如: P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR Set-Cookie 作用： 非常重要的header, 用于把cookie 发送到客户端浏览器， 每一个写入cookie都会生成一个Set-Cookie. 例如: Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/ Entity实体头域：实体内容的属性，包括实体信息类型，长度，压缩方法，最后一次修改时间，数据有效性等 ETag： 作用: 和If-None-Match 配合使用。 （实例请看上节中If-None-Match的实例） 例如: ETag: “03f2b33c0bfcc1:0” Last-Modified： 作用： 用于指示资源的最后修改日期和时间。（实例请看上节的If-Modified-Since的实例） 例如: Last-Modified: Wed, 21 Dec 2011 09:09:10 GMT Content-Type： 作用：WEB服务器告诉浏览器自己响应的对象的类型和字符集, 例如: Content-Type: text/html; charset=utf-8 Content-Type:text/html;charset=GB2312 Content-Type: image/jpeg Content-Length： 指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。 例如: Content-Length: 19847 Content-Encoding： 作用：文档的编码（Encode）方法。一般是压缩方式。 WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。利用gzip压缩文档能够显著地减少HTML文档的下载时间。 例如：Content-Encoding：gzip Content-Language： 作用： WEB服务器告诉浏览器自己响应的对象的语言者 例如： Content-Language:da Miscellaneous 头域 Server： 作用：指明HTTP服务器的软件信息 例如:Apache/2.2.8 (Win32) PHP/5.2.5 X-Powered-By： 作用：表示网站是用什么技术开发的 例如： X-Powered-By: PHP/5.2.5 Transport头域 Connection： 例如： Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接 例如： Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。 Location头域 Location： 作用： 用于重定向一个新的位置， 包含新的URL地址 实例请看304状态实例 HTTP协议是无状态的和Connection: keep-alive的区别 无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。 HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。 从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。 Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。 浏览器缓存 浏览器缓存：包括页面html缓存和图片js，css等资源的缓存。如下图，浏览器缓存是基于把页面信息保存到用户本地电脑硬盘里。缓存的优点：1）服务器响应更快：因为请求从缓存服务器（离客户端更近）而不是源服务器被相应，这个过程耗时更少，让服务器看上去响应更快。2）减少网络带宽消耗：当副本被重用时会减低客户端的带宽消耗；客户可以节省带宽费用，控制带宽的需求的增长并更易于管理。1、缓存工作原理 页面缓存状态是由http header决定的，一个浏览器请求信息，一个是服务器响应信息。主要包括Pragma: no-cache、Cache-Control、 Expires、 Last-Modified、If-Modified-Since。其中Pragma: no-cache由HTTP/1.0规定，Cache-Control由HTTP/1.1规定。 工作原理图：从图中我们可以看到原理主要分三步： 第一次请求：浏览器通过http的header报头，附带Expires，Cache-Control，Last-Modified/Etag向服务器请求，此时服务器记录第一次请求的Last-Modified/Etag 再次请求：当浏览器再次请求的时候，请求头附带Expires，Cache-Control，If-Modified-Since/Etag向服务器请求 服务器根据第一次记录的Last-Modified/Etag和再次请求的If-Modified-Since/Etag做对比，判断是否需要更新，服务器通过这两个头判断本地资源未发生变化，客 户端不需要重新下载，返回304响应。常见流程如下图所示：与缓存相关的HTTP扩展消息头 Expires：设置页面过期时间，格林威治时间GMT Cache-Control：更细致的控制缓存的内容 Last-Modified：请求对象最后一次的修改时间 用来判断缓存是否过期 通常由文件的时间信息产生 ETag：响应中资源的校验值，在服务器上某个时段是唯一标识的。ETag是一个可以 与Web资源关联的记号（token），和Last-Modified功能才不多，也是一个标识符，一般和Last-Modified一起使用，加强服务器判断的准确度。 Date：服务器的时间 If-Modified-Since：客户端存取的该资源最后一次修改的时间，用来和服务器端的Last-Modified做比较 If-None-Match：客户端存取的该资源的检验值，同ETag。 Cache-Control的主要参数Cache-Control: private/public Public 响应会被缓存，并且在多用户间共享。 Private 响应只能够作为私有的缓存，不能再用户间共享。Cache-Control: no-cache：不进行缓存Cache-Control: max-age=x：缓存时间 以秒为单位Cache-Control: must-revalidate：如果页面是过期的 则去服务器进行获取。","raw":null,"content":null,"categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.congboss.top/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.congboss.top/tags/计算机网络/"}]},{"title":"HTTP工作原理","slug":"HTTP工作原理","date":"2018-01-02T06:07:23.000Z","updated":"2018-08-04T16:44:41.567Z","comments":true,"path":"2018/01/02/HTTP工作原理/","link":"","permalink":"http://www.congboss.top/2018/01/02/HTTP工作原理/","excerpt":"\nHTTP简介\n\n\nHTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。在了解HTTP如何工作之前，我们先了解计算机之间的通信。","text":"HTTP简介 HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。在了解HTTP如何工作之前，我们先了解计算机之间的通信。 计算机相互之间的通信 互联网的关键技术就是TCP/IP协议。两台计算机之间的通信是通过TCP/IP协议在因特网上进行的。实际上这个是两个协议： TCP : Transmission Control Protocol 传输控制协议和IP： Internet Protocol 网际协议。 IP：计算机之间的通信 IP协议是计算机用来相互识别的通信的一种机制，每台计算机都有一个IP.用来在internet上标识这台计算机。 IP 负责在因特网上发送和接收数据包。通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。IP 负责将每个包路由至它的目的地。 IP协议仅仅是允许计算机相互发消息，但它并不检查消息是否以发送的次序到达而且没有损坏（只检查关键的头数据）。为了提供消息检验功能，直接在IP协议上设计了传输控制协议TCP. TCP : 应用程序之间的通信 TCP确保数据包以正确的次序到达，并且尝试确认数据包的内容没有改变。TCP在IP地址之上引端口（port），它允许计算机通过网络提供各种服务。一些端口号为不同的服务保留，而且这些端口号是众所周知。 服务或者守护进程：在提供服务的机器上，有程序监听特定端口上的通信流。例如大多数电子邮件通信流出现在端口25上，用于wwww的HTTP通信流出现在80端口上。 当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信，占用两个计算机之间整个的通信线路。TCP 用于从应用程序到网络的数据传输控制。TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。 TCP/IP 就是TCP 和 IP 两个协议在一起协同工作，有上下层次的关系。 TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。IP 负责计算机之间的通信。TCP 负责将数据分割并装入 IP 包，IP 负责将包发送至接受者，传输过程要经IP路由器负责根据通信量、网络中的错误或者其他参数来进行正确地寻址，然后在它们到达的时候重新组合它们。 HTTP协议所在的协议层 HTTP是基于TCP协议之上的。在TCP/IP协议参考模型的各层对应的协议如下图,其中HTTP是应用层的协议。 HTTP请求响应模型 HTTP由请求和响应构成，是一个标准的客户端服务器模型（B/S）。HTTP协议永远都是客户端发起请求，服务器回送响应。见下图:HTTP是一个无状态的协议。无状态是指客户机（Web浏览器）和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.HTTP遵循请求(Request)/应答(Response)模型。客户机（浏览器）向服务器发送请求，服务器处理请求并返回适当的应答。所有HTTP连接都被构造成一套请求和应答。 HTTP工作过程 一次HTTP操作称为一个事务，其工作整个过程如下： 1 ) 、地址解析 如用客户端浏览器请求这个页面：http://localhost.com:8080/index.htm 从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：协议名：http主机名：localhost.com端口：8080对象路径：/index.htm 在这一步，需要域名系统DNS解析域名localhost.com,得主机的IP地址。 2）、封装HTTP请求数据包 把以上部分结合本机自己的信息，封装成一个HTTP请求数据包 3）封装成TCP包，建立TCP连接（TCP的三次握手） 在HTTP工作开始之前，客户机（Web浏览器）首先要通过网络与服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。这里是8080端口 4）客户机发送请求命令 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可内容。 5）服务器响应 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据 6）服务器关闭TCP连接 一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码 Connection:keep-alive TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 HTTP协议栈中各层数据流 首先我们看看客户端请求的时候，数据在各层协议的数据组织如下图： 而服务器解析客户机请求就是反向操作的过程，如下图：客户机发起一次请求的时候： 客户机会将请求封装成http数据包–&gt;封装成Tcp数据包–&gt;封装成Ip数据包—&gt;封装成数据帧—&gt;硬件将帧数据转换成bit流（二进制数据）–&gt;最后通过物理硬件（网卡芯片）发送到指定地点。 服务器硬件首先收到bit流……. 然后转换成ip数据包。于是通过ip协议解析Ip数据包，然后又发现里面是tcp数据包，就通过tcp协议解析Tcp数据包，接着发现是http数据包通过http协议再解析http数据包得到数据。 HTTPS实现原理 HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL。其所用的端口号是443。 SSL：安全套接层，是netscape公司设计的主要用于web的安全传输协议。这种协议在WEB上获得了广泛的应用。通过证书认证来确保客户端和网站服务器之间的通信数据是加密安全的。 有两种基本的加解密算法类型： 1）对称加密（symmetrcic encryption）：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES，RC5，3DES等； 对称加密主要问题是共享秘钥，除你的计算机（客户端）知道另外一台计算机（服务器）的私钥秘钥，否则无法对通信流进行加密解密。解决这个问题的方案非对称秘钥。 2）非对称加密：使用两个秘钥：公共秘钥和私有秘钥。私有秘钥由一方密码保存（一般是服务器保存），另一方任何人都可以获得公共秘钥。 这种密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。 下面看一下https的通信过程：过程大致如下：1） SSL客户端通过TCP和服务器建立连接之后（443端口），并且在一般的tcp连接协商（握手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共秘钥）。2）Client在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。3）如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。 https通信的优点： 1）客户端产生的密钥只有客户端和服务器端能得到； 2）加密的数据只有客户端和服务器端才能得到明文； 3）客户端到服务端的通信是安全的。 HTTP各种长度限制 1. URL长度限制在Http1.1协议中并没有提出针对URL的长度进行限制，RFC协议里面是这样描述的，HTTP协议并不对URI的长度做任何的限制，服务器端必须能够处理任何它们所提供服务多能接受的URI，并且能够处理无限长度的URI,如果服务器不能处理过长的URI,那么应该返回414状态码。 虽然Http协议规定了，但是Web服务器和浏览器对URI都有自己的长度限制。 服务器的限制:我接触的最多的服务器类型就是Nginx和Tomcat,对于url的长度限制，它们都是通过控制http请求头的长度来进行限制的，nginx的配置参数为large_client_header_buffers，tomcat的请求配置参数为maxHttpHeaderSize,都是可以自己去进行设置。 浏览器的限制:每种浏览器也会对url的长度有所限制，下面是几种常见浏览器的url长度限制:(单位:字符)IE : 2803Firefox:65536Chrome:8182Safari:80000Opera:190000 对于get请求，在url的长度限制范围之内，请求的参数个数没有限制。 2. Post数据的长度限制Post数据的长度限制与url长度限制类似，也是在Http协议中没有规定长度限制,长度限制可以在服务器端配置最大http请求头长度的方式来实现。 3. Cookie的长度限制Cookie的长度限制分这么几个方面来总结。 (1) 浏览器所允许的每个域下的最大cookie数目,没有去自己测试，从网上找到的资料大概是这么个情况IE :原先为20个，后来升级为50个Firefox: 50个Opera:30个Chrome:180个Safari:无限制 当Cookie数超过限制数时浏览器的行为：IE和Opera会采用LRU算法将老的不常使用的Cookie清除掉，Firefox的行为是随机踢出某些Cookie的值。当然无论怎样的策略，还是尽量不要让Cookie数目超过浏览器所允许的范围。 (2) 浏览器所允许的每个Cookie的最大长度 Firefox和Safari:4079字节Opera:4096字节IE:4095字节 (3) 服务器中Http请求头长度的限制。Cookie会被附在每次http请求头中传递给服务器，因此还会受到服务器请求头长度的影响。 4. Html5 LocalStorageHtml5提供了本地存储机制来供Web应用在客户端存储数据，尽管这个并不属于Http协议的一部分，但是随着Html5的流行，我们可能需要越来越多使用LocalStorage,甚至当它普及的时候跟它打交道就会同今天我们跟Cookie打交道一样多。 对于LocalStorage的长度限制，同Cookie的限制类似，也是浏览器针对域来限制,只不过cookie限制的是个数，LocalStorage限制的是长度: Firefox\\Chrome\\Opera都是允许每个域的最大长度为5MB但是这次IE比较大方，允许的最大长度是10MB","raw":null,"content":null,"categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.congboss.top/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.congboss.top/tags/计算机网络/"}]},{"title":"HTTPS通信过程","slug":"HTTPS通信过程","date":"2017-12-29T06:02:23.000Z","updated":"2018-08-04T16:09:14.361Z","comments":true,"path":"2017/12/29/HTTPS通信过程/","link":"","permalink":"http://www.congboss.top/2017/12/29/HTTPS通信过程/","excerpt":"我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取。所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。\nHTTPS简介HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。具体是如何进行加密，解密，验证的，且看下图。","text":"我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取。所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。 HTTPS简介HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。具体是如何进行加密，解密，验证的，且看下图。 1. 客户端发起HTTPS请求 这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。 2. 服务端的配置 采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。 3. 传送证书 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。 4. 客户端解析证书 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。 5. 传送加密信息 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 6. 服务段解密信息 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 7. 传输加密后的信息 这部分信息是服务段用私钥加密后的信息，可以在客户端被还原 8. 客户端解密信息 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。","raw":null,"content":null,"categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.congboss.top/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.congboss.top/tags/计算机网络/"}]},{"title":"二叉树锯齿形遍历","slug":"二叉树锯齿形遍历","date":"2017-12-29T03:00:42.000Z","updated":"2018-03-12T11:01:27.659Z","comments":true,"path":"2017/12/29/二叉树锯齿形遍历/","link":"","permalink":"http://www.congboss.top/2017/12/29/二叉树锯齿形遍历/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; wrapList=new LinkedList&lt;List&lt;Integer&gt;&gt;(); if(root==null) return wrapList; boolean flag=true; Queue&lt;TreeNode&gt; queue=new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while(!queue.isEmpty()) &#123; int level=queue.size(); List&lt;Integer&gt; subList=new LinkedList&lt;&gt;(); for(int i=0;i&lt;level;i++) &#123; TreeNode n=queue.poll(); if(flag) &#123; subList.add(n.val); &#125; else &#123; subList.add(0,n.val); &#125; if(n.left!=null) queue.offer(n.left); if(n.right!=null) queue.offer(n.right); &#125; flag=flag?false:true; wrapList.add(subList); &#125; return wrapList; &#125; &#125; 注意：用好poll和peek的区别~","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"计算机网络传输层相关知识","slug":"计算机网络传输层","date":"2017-12-27T10:02:23.000Z","updated":"2018-08-04T11:54:26.094Z","comments":true,"path":"2017/12/27/计算机网络传输层/","link":"","permalink":"http://www.congboss.top/2017/12/27/计算机网络传输层/","excerpt":"传输层概述\n作用：传输层为它上面的应用层提供通信服务。\n在OSI七层参考模型中，传输层是面向通信的最高层，也是用户功能的最底层。\n传输层两大重要的功能：复用 和 分用。 \n复用：在发送端，多个应用进程公用一个传输层；\n分用：在接收端，传输层会根据端口号将数据分派给不同的应用进程。\n\n\n和网络层的区别： \n\n\n网络层为不同主机提供通信服务，而传输层为不同主机的不同应用提供通信服务。\n网络层只对报文头部进行差错检测，而传输层对整个报文进行差错检测。","text":"传输层概述 作用：传输层为它上面的应用层提供通信服务。 在OSI七层参考模型中，传输层是面向通信的最高层，也是用户功能的最底层。 传输层两大重要的功能：复用 和 分用。 复用：在发送端，多个应用进程公用一个传输层； 分用：在接收端，传输层会根据端口号将数据分派给不同的应用进程。 和网络层的区别： 网络层为不同主机提供通信服务，而传输层为不同主机的不同应用提供通信服务。 网络层只对报文头部进行差错检测，而传输层对整个报文进行差错检测。 UDP（用户数据报协议）详解 UDP的特点： UDP只在IP数据报服务的基础上增加了少量的功能：复用与分用、对整个报文的差错检测。 UDP是无连接的通信前不需要建立连接，通信结束也无需释放连接。 UDP是不可靠的它是尽力而为交付，不能确保每一个数据报都送达。 UDP是面向报文的所谓『面向报文』就是指：UDP数据传输的单位是报文，且不会对数据作任何 拆分 和 拼接 操作。在发送端，应用程序给传输层的UDP什么样的数据，UDP不会对数据进行切分，只增加一个UDP头并交给网络层。在接收端，UDP收到网络层的数据报后，去除IP数据报头部后遍交给应用层，不会作任何拼接操作。 UDP没有拥塞控制UDP始终以恒定的速率发送数据，并不会根据网络拥塞情况对发送速率作调整。这种方式有利有弊。弊端：网络拥塞时有些报文可能会丢失，因此UDP不可靠。优点：有些使用场景允许报文丢失，如：直播、语音通话，但对实时性要求很高，此时UDP还是很有用武之地的。 UDP支持一对一、一对多、多对多、多对一通信而TCP只支持一对一通信。 UDP首部开销小，只有8字节。而TCP头部至少由20字节，相比于TCP要高效很多。 PS：问：UDP不可靠具体体现在哪些方面？数据报丢失，数据报顺序。 UDP报文头 源端口 目的端口 长度：整个数据报的长度 检验和：整个数据报的检验和 TCP（传输控制协议）详解TCP特点 TCP是面向连接的通信前需要建立连接，通信结束需要释放连接。 TCP提供可靠交付服务所谓『可靠』指的是：TCP发送的数据无重复、无丢失、无错误、与发送端顺序一致。 TCP是面向字节流的所谓『面向字节流』指的是：TCP以字节为单位。虽然传输的过程中数据被划分成一个个数据报，但这只是为了方便传输，接收端最终接受到的数据将与发送端的数据一模一样。 TCP提供全双工通信所谓『全双工通信』指的是：TCP的两端既可以作为发送端，也可以作为接收端。 一条TCP连接的两端只能有两个端点TCP只能提供点到点的通信，而UDP可以任意方式的通信。 TCP连接 与 套接字 什么是『TCP连接』？TCP连接是一种抽象的概念，表示一条可以通信的链路。每条TCP连接有且仅有两个端点，表示通信的双方。且双发在任意时刻都可以作为发送者和接收者。 什么是『套接字』？一条TCP连接的两端就是两个套接字。套接字=IP地址:端口号。因此，TCP连接=（套接字1，套接字2）=（IP1:端口号1，IP2:端口号2） TCP头部 TCP头部长度有20字节的固定部分，选项部分长度不定，但最多40字节，因此TCP头部在20-60字节之间。 源端口 和 目的端口传输层和网络层一大重要区别就是传输层指定了数据报发往的应用进程，因此需要端口号标识。 序号当前TCP数据报数据部分的第一个字节的序号。我们知道，TCP是面向字节的，它会对发送的每一个字节进行编号，而且不同数据报之间是连续编号的。由于本字段4字节，可以给[0,2^32-1]个字节进行编号（大约4G），而且序号循环使用，当发送完2^32-1个字节后，序号又从0开始。一般来说，当2^32-1个字节被发送的时候，前面的字节早就发送成功了，因此序号可以循环使用。 确认号表示当前主机作为接收端时，期望接收的下一个字节的编号是多少。也表示，当前主机已经正确接收的最后一个字节序号+1。 数据偏移（报文长度）它表明了数据报头部的长度。 保留字段 标识符TCP有7种标识符，用于表示TCP报文的性质。它们只能为0或1。 URG=1当URG字段被置1，表示本数据报的数据部分包含紧急信息，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。如control+c：这个命令要求操作系统立即停止当前进程。此时，这条命令就会存放在数据包数据部分的开头，并由紧急指针标识命令的位置，并URG字段被置1。 ACK=1ACK被置1后确认号字段才有效。此外，TCP规定，在连接建立后传送的所有报文段都必须把ACK置1。 PSH=1当接收方收到PSH=1的报文后，会立即将数据交付给应用程序，而不会等到缓冲区满后再提交。一些交互式应用需要这样的功能，降低命令的响应时间。 RST=1当该值为1时，表示当前TCP连接出现严重问题，必须要释放重连。 SYN=1SYN在建立连接时使用。当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。 FIN=1FIN=1表示此报文段是一个释放连接的请求报文。 接收窗口大小该字段用于实现TCP的流量控制。它表示当前接收方的接收窗口的剩余容量，发送方收到该值后会将发送窗口调整成该值的大小。发送窗口的大小又决定了发送速率，所以接收方通过设置该值就可以控制发送放的发送速率。发送方每收到一个数据报都要调整当前的发送窗口。 检验和用于接收端检验整个数据包在传输过程中是否出错。 紧急指针用于标识紧急数据的尾部。 选项字段上述字段都是每个TCP头部必须要有的，而选项字段是可选的，且长度可变，最长40字节。最常用的选项字段为MMS：最大报文长度。 TCP三次握手 TCP协议中，主动发起请求的一端称为『客户端』，被动连接的一端称为『服务端』。不管是客户端还是服务端，TCP连接建立完后都能发送和接收数据。 起初，服务器和客户端都为CLOSED状态。在通信开始前，双方都得创建各自的传输控制块（TCB）。服务器创建完TCB后遍进入LISTEN状态，此时准备接收客户端发来的连接请求。 第一次握手 客户端向服务端发送连接请求报文段。该报文段的头部中SYN=1，ACK=0，seq=x。请求发送后，客户端便进入SYN-SENT状态。 PS1：SYN=1，ACK=0表示该报文段为连接请求报文。 PS2：x为本次TCP通信的字节流的初始序号。TCP规定：SYN=1的报文段不能有数据部分，但要消耗掉一个序号。第二次握手 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=1，ACK=1，seq=y，ack=x+1。该应答发送完成后便进入SYN-RCVD状态。 PS1：SYN=1，ACK=1表示该报文段为连接同意的应答报文。 PS2：seq=y表示服务端作为发送者时，发送字节流的初始序号。 PS3：ack=x+1表示服务端希望下一个数据报发送序号从x+1开始的字节。第三次握手 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。该报文段的头部为：ACK=1，seq=x+1，ack=y+1。客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接的建立完成！ 为什么连接建立需要三次握手，而不是两次握手？防止失效的连接请求报文段被服务端接收，从而产生错误。 PS：失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。 若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入ESTABLISHED状态，而服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。 TCP四次挥手TCP连接的释放一共需要四步，因此称为『四次挥手』。我们知道，TCP连接是双向的，因此在四次挥手中，前两次挥手用于断开一个方向的连接，后两次挥手用于断开另一方向的连接。 第一次挥手若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带的主要参数为：FIN=1，seq=u。此时，A将进入FIN-WAIT-1状态。 PS1：FIN=1表示该报文段是一个连接释放请求。PS2：seq=u，u-1是A向B发送的最后一个字节的序号。第二次挥手 B收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入CLOSE-WAIT状态，并向A发送连接释放的应答，其报文头包含：ACK=1，seq=v，ack=u+1。 PS1：ACK=1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都为1，表示应答。PS2：seq=v，v-1是B向A发送的最后一个字节的序号。PS3：ack=u+1表示希望收到从第u+1个字节开始的报文段，并且已经成功接收了前u个字节。A收到该应答，进入FIN-WAIT-2状态，等待B发送连接释放请求。 第二次挥手完成后，A到B方向的连接已经释放，B不会再接收数据，A也不会再发送数据。但B到A方向的连接仍然存在，B可以继续向A发送数据。 第三次挥手当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN=1，ACK=1，seq=w，ack=u+1。B便进入LAST-ACK状态。 第四次挥手A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续2MSL时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCB。当B收到确认应答后，也便进入CLOSED状态，撤销TCB。 为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？ 为了保证B能收到A的确认应答。若A发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，B等待超时后就会重新发送连接释放请求，但此时A已经关闭了，不会作出任何响应，因此B永远无法正常关闭。 TCP可靠传输的实现TCP的可靠性表现在：它向应用层提供的数据是 无差错的、有序的、无丢失的，简单的说就是：TCP最终递交给应用层的数据和发送者发送的数据是一模一样的。TCP采用了流量控制、拥塞控制、连续ARQ等技术来保证它的可靠性。 PS：网络层传输的数据单元为『数据报』，传输层的数据单元为『报文段』，但为了方便起见，可以统称为『分组』。 停止等待协议（ARQ协议）TCP保证其可靠性采用的是更为复杂的滑动窗口协议，但停止等待协议是它的简化版，为了方便理解，这里先介绍停止等待协议。 AQR协议 ARQ(Automatic Repeat reQuest)自动重传请求。顾名思义，当请求失败时它会自动重传，直到请求被正确接收为止。这种机制保证了每个分组都能被正确接收。停止等待协议是一种ARQ协议。 停止等待协议的原理 无差错的情况A向B每发送一个分组，都要停止发送，等待B的确认应答；A只有收到了B的确认应答后才能发送下一个分组。 分组丢失和出现差错的情况发送者拥有超时计时器。每发送一个分组便会启动超时计时器，等待B的应答。若超时仍未收到应答，则A会重发刚才的分组。分组出现差错：若B收到分组，但通过检查和字段发现分组在运输途中出现差错，它会直接丢弃该分组，并且不会有任何其他动作。A超时后便会重新发送该分组，直到B正确接收为止。分组丢失：若分组在途中丢失，B并没有收到分组，因此也不会有任何响应。当A超时后也会重传分组，直到正确接收该分组的应答为止。综上所述：当分组丢失 或 出现差错 的情况下，A都会超时重传分组。 应答丢失 和 应答迟到 的情况TCP会给每个字节都打上序号，用于判断该分组是否已经接收。应答丢失：若B正确收到分组，并已经返回应答，但应答在返回途中丢失了。此时A也收不到应答，从而超时重传。紧接着B又收到了该分组。接收者根据序号来判断当前收到的分组是否已经接收，若已接收则直接丢弃，并补上一个确认应答。应答迟到：若由于网络拥塞，A迟迟收不到B发送的应答，因此会超时重传。B收到该分组后，发现已经接收，便丢弃该分组，并向A补上确认应答。A收到应答后便继续发送下一个分组。但经过了很长时间后，那个失效的应答最终抵达了A，此时A可根据序号判断该分组已经接收，此时只需简单丢弃即可。 停止等待协议的注意点 每发送完一个分组，该分组必须被保留，直到收到确认应答为止。必须给每个分组进行编号。以便按序接收，并判断该分组是否已被接收。必须设置超时计时器。每发送一个分组就要启动计时器，超时就要重发分组。计时器的超时时间要大于应答的平均返回时间，否则会出现很多不必要的重传，降低传输效率。但超时时间也不能太长。 滑动窗口协议（连续ARQ协议）连续ARQ协议 在ARQ协议发送者每次只能发送一个分组，在应答到来前必须等待。而连续ARQ协议的发送者拥有一个发送窗口，发送者可以在没有得到应答的情况下连续发送窗口中的分组。这样降低了等待时间，提高了传输效率。 累计确认 在连续ARQ协议中，接收者也有个接收窗口，接收者并不需要每收到一个分组就返回一个应答，可以连续收到分组之后统一返回一个应答。这样能节省流量。TCP头部的ack字段就是用来累计确认，它表示已经确认的字节序号+1，也表示期望发送者发送的下一个分组的起始字节号。 发送窗口 发送窗口的大小由接收窗口的剩余大小决定。接收者会把当前接收窗口的剩余大小写入应答TCP报文段的头部，发送者收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小。发送窗口的大小是不断变化的。发送窗口由三个指针构成： p1p1指向发送窗口的后沿，它后面的字节表示已经发送且已收到应答。 p2p2指向尚未发送的第一个字节。p1-p2间的字节表示已经发送，但还没收到确认应答。这部分的字节仍需保留，因为可能还要超时重发。p2-p3间的字节表示可以发送，但还没有发送的字节。 p3p3指向发送窗口的前沿，它前面的字节尚未发送，且不允许发送。发送者每收到一个应答，后沿就可以向前移动指定的字节。此时若窗口大小仍然没变，前沿也可以向前移动指定字节。当p2和前沿重合时，发送者必须等待确认应答。 接收窗口接收者收到的字节会存入接收窗口，接收者会对已经正确接收的有序字节进行累计确认，发送完确认应答后，接收窗口就可以向前移动指定字节。如果某些字节并未按序收到，接收者只会确认最后一个有序的字节，从而乱序的字节就会被重新发送。 连续ARQ的注意点 同一时刻发送窗口的大小并不一定和接收窗口一样大。虽然发送窗口的大小是根据接收窗口的大小来设定的，但应答在网络中传输是有时间的，有可能t1时间接收窗口大小为m，但当确认应答抵达发送者时，接收窗口的大小已经发生了变化。此外发送窗口的大小还随网络拥塞情况影响。当网络出现拥塞时，发送窗口将被调小。 TCP标准并未规定未按序到达的字节的处理方式。但TCP一般都会缓存这些字节，等缺少的字节到达后再交给应用层处理。这比直接丢弃乱序的字节要节约带宽。 TCP标准规定接收方必须要有累计确认功能。接收方可以对多个TCP报文段同时确认，但不能拖太长时间，一般是0.5S以内。此外，TCP允许接收者在有数据要发送的时候捎带上确认应答。但这种情况一般较少，因为一般很少有两个方向都要发送数据的情况。 流量控制什么是流量控制？如果发送者发送过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。 流量控制的目的？流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。 如何实现流量控制？由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。 流量控制引发的死锁当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。 持续计时器为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。 拥塞控制拥塞控制 和 流量控制 的区别？ 拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况； 流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收。PS：拥塞控制是针对于网络而言的，它是防止往网络中写入太多分组，从而导致网络拥塞的情况；而流量控制是针对接收者的，它是通过控制发送者的发送速度保证接收者能够来得及接收。 拥塞控制的目的？ 缓解网络压力 保证分组按时到达 慢开始算法 和 拥塞避免算法 发送方维护一个发送窗口，发送窗口的大小取决于网络的拥塞情况和接收窗口的大小，发送窗口是动态变化的。 发送方还维护一个慢开始门限 发送窗口 &lt; 慢开始门限：使用慢开始算法 发送窗口 &gt; 慢开始门限：使用拥塞避免算法 发送窗口 = 慢开始门限：使用慢开始算法或拥塞避免算法 算法的具体过程： 通信开始时，发送方的发送窗口设为1，并发送第一个分组M1； 接收方收到M1后，返回确认应答，此时发送方发送窗口扩大两倍，并发送M2、M3；（即，发送方每次收到确认应答后，都将发送窗口设为当前值的两倍） 若发送窗口&gt;慢开始门限，则使用拥塞避免算法，每次收到确认应答后都将发送窗口+1； 若发送方出现了超时重传，则表明网络出现拥塞，此时：a）慢开始门限设为当前发送窗口的一半；b）发送窗口设为1；c）启用拥塞避免算法；PS：发送超时重传时，发送窗口有可能已经超过了慢开始门限，也有可能还没超过；此时不管何种情况，都一律启用拥塞避免算法，并执行上述三步操作！ 慢开始算法的作用：慢开始算法将发送窗口从小扩大，而且按指数级扩大，从而避免一开始就往网络中注入过多的分组从而导致拥塞；它将窗口慢慢扩大的过程其实也在探测网络拥塞情况的过程，当发现出现拥塞时，及时降低发送速度，从而减缓网络拥塞。 拥塞避免算法的作用：拥塞避免算法使发送窗口以线性方式增长，而非指数级增长，从而使网络更加不容易发生拥塞。 AIMD算法（加法增大乘法减小算法）慢开始算法 和 拥塞避免算法 还有个名称叫做『加法增大乘法减小算法』。 加法增加：指的是拥塞避免算法，使得发送窗口以线性的方式增长； 乘法减小：指的是不管当前正使用慢开始算法还是拥塞避免算法，只要发生拥塞时，慢开始门限将会变成当前窗口的一半。快重传算法 和 快恢复算法 上述慢开始算法和拥塞避免算法能保证网络出现拥塞时进行相应的处理，而快重传和快恢复是一种拥塞预防的方式，此时网络可能尚未出现拥塞，但已经有拥塞的征兆，因此得作出一些预防措施。 快重传原理：因为TCP具有累计确认的能力，因此接收者收到一个分组的时候不会立即发出应答，可能需要等待收到多个分组之后再同一发出累计确认。但快重传算法就要求，接收者如果接收到一个乱序的分组的话，就必须立即发出前一个正确分组的确认应答，这样能让发送者尽早地知道有一个分组可能丢失。 快恢复原理：当发送者收到同一个分组的三个确认应答后，就基本可以判断这个分组已经丢失了；这时候无需等待超时，直接执行『乘法减小加法增大』： 将慢开始门限减半； 将发送窗口减半（不设为1）； 使用拥塞避免算法；","raw":null,"content":null,"categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.congboss.top/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.congboss.top/tags/计算机网络/"}]},{"title":"把数组排成最小的数","slug":"把数组排成最小的数","date":"2017-12-22T14:20:42.000Z","updated":"2018-03-23T07:04:05.034Z","comments":true,"path":"2017/12/22/把数组排成最小的数/","link":"","permalink":"http://www.congboss.top/2017/12/22/把数组排成最小的数/","excerpt":"","text":"输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。123456789101112131415161718192021222324252627import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;public class Solution &#123; public String PrintMinNumber(int [] numbers) &#123;int n=numbers.length; ArrayList&lt;Integer&gt; temp=new ArrayList&lt;&gt;(); for(int i=0;i&lt;n;i++) &#123; temp.add(numbers[i]); &#125; Collections.sort(temp,new Comparator&lt;Integer&gt;() &#123; public int compare(Integer a,Integer b) &#123; return(a+\"\"+b).compareTo(b+\"\"+a); &#125; &#125; ); String ss=\"\"; for(int i=0;i&lt;temp.size();i++) &#123; ss+=temp.get(i); &#125; return ss; &#125;&#125; TIPS：重写Compare方法~","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"Add Two Numbers","slug":"Add Two Numbers","date":"2017-12-21T14:20:42.000Z","updated":"2018-03-23T02:56:38.199Z","comments":true,"path":"2017/12/21/Add Two Numbers/","link":"","permalink":"http://www.congboss.top/2017/12/21/Add Two Numbers/","excerpt":"","text":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807. 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode prev=new ListNode(0); ListNode head=prev; int carry=0; while(l1!=null||l2!=null||carry!=0) &#123; ListNode cur=new ListNode(0); int sum=((l2==null)?0 :l2.val)+((l1==null)?0 :l1.val)+carry; carry=sum/10; cur.val=sum%10; prev.next=cur; prev=cur; l1=((l1==null)?l1:l1.next); l2=((l2==null)?l2:l2.next); &#125; return head.next; &#125;&#125; TIPS：链表一旦为空，则直接输出为0","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"二叉搜索树中搜索区间","slug":"验证二叉搜索树","date":"2017-12-20T03:00:42.000Z","updated":"2018-03-11T13:28:15.750Z","comments":true,"path":"2017/12/20/验证二叉搜索树/","link":"","permalink":"http://www.congboss.top/2017/12/20/验证二叉搜索树/","excerpt":"","text":"Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key.The right subtree of a node contains only nodes with keys greater than the node’s key.Both the left and right subtrees must also be binary search trees.1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isValidBST(TreeNode root) &#123; return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE); &#125; public boolean isValidBST(TreeNode root,long min,long max) &#123; if(root==null) return true; if(root.val&gt;=max||root.val&lt;=min) return false; return(isValidBST(root.left,min,root.val)&amp;&amp;isValidBST(root.right,root.val,max)); &#125; &#125;","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"合并两个排序链表","slug":"合并两个排序链表","date":"2017-12-19T04:00:42.000Z","updated":"2018-03-11T13:35:30.761Z","comments":true,"path":"2017/12/19/合并两个排序链表/","link":"","permalink":"http://www.congboss.top/2017/12/19/合并两个排序链表/","excerpt":"","text":"Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null) return l2; if(l2==null) return l1; ListNode ans; if(l1.val&lt;l2.val) &#123; ans=l1; ans.next=mergeTwoLists(l1.next,l2); &#125; else &#123; ans=l2; ans.next=mergeTwoLists(l1,l2.next); &#125; return ans; &#125;&#125;","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"中序和后序遍历构造二叉树","slug":"中序和后序遍历构造二叉树","date":"2017-12-19T03:00:42.000Z","updated":"2018-03-12T05:35:30.967Z","comments":true,"path":"2017/12/19/中序和后序遍历构造二叉树/","link":"","permalink":"http://www.congboss.top/2017/12/19/中序和后序遍历构造二叉树/","excerpt":"","text":"Given inorder and postorder traversal of a tree, construct the binary tree.1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] inorder, int[] postorder) &#123; int n=inorder.length-1; if(inorder.length!=postorder.length) &#123; return null; &#125; return helpbuild(inorder,0,n,postorder,0,n); &#125; public TreeNode helpbuild(int []inorder,int inLow,int inHigh,int [] postorder,int postLow,int postHigh) &#123; if(inLow&gt;inHigh||postLow&gt;postHigh) return null; TreeNode root=new TreeNode(postorder[postHigh]); int inroot=intLow; for(int i=0;i&lt;inorder.length;i++) &#123; if(inorder[i]==root.val) &#123; inroot=i; &#125; &#125; int leftLen=inroot-inLow; root.left=helpbuild(inorder,inLow,inroot-1,postorder,postLow,postLow+leftLen-1); root.right=helpbuild(inorder,inroot+1,inHigh,postorder,postLow+leftLen,postHigh-1);//注意取值，结合实例 return root; &#125; &#125;","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"合并K个排序链表","slug":"合并K个排序链表","date":"2017-12-19T03:00:42.000Z","updated":"2018-03-11T13:25:29.575Z","comments":true,"path":"2017/12/19/合并K个排序链表/","link":"","permalink":"http://www.congboss.top/2017/12/19/合并K个排序链表/","excerpt":"","text":"Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if(lists==null||lists.length==0) return null; PriorityQueue&lt;ListNode&gt; queue=new PriorityQueue&lt;ListNode&gt;(lists.length,new Comparator&lt;ListNode&gt;()&#123; public int compare(ListNode o1,ListNode o2) &#123; if(o1.val&lt;o2.val) return -1; else if(o1.val&gt;o2.val) return 1; else return 0; &#125; &#125;); ListNode dummy=new ListNode(0); ListNode tail=dummy; for(ListNode node:lists) &#123; if(node!=null) queue.add(node); &#125; while(!queue.isEmpty()) &#123; tail.next=queue.poll(); tail=tail.next; if(tail.next!=null) queue.add(tail.next); &#125; return dummy.next; &#125;&#125; 思路：使用了优先权队列，采取了最小堆的策略，每次队列弹出的都是最小的数据。","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"二叉搜索树中搜索区间","slug":"二叉查找树中搜索区间","date":"2017-12-18T03:00:42.000Z","updated":"2018-03-11T07:53:34.025Z","comments":true,"path":"2017/12/18/二叉查找树中搜索区间/","link":"","permalink":"http://www.congboss.top/2017/12/18/二叉查找树中搜索区间/","excerpt":"","text":"给定两个值 k1 和 k2（k1 &lt; k2）和一个二叉查找树的根节点。找到树中所有值在 k1 到 k2 范围内的节点。即打印所有x (k1 &lt;= x &lt;= k2) 其中 x 是二叉查找树的中的节点值。返回所有升序的节点值。123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition of TreeNode: * public class TreeNode &#123; * public int val; * public TreeNode left, right; * public TreeNode(int val) &#123; * this.val = val; * this.left = this.right = null; * &#125; * &#125; */public class Solution &#123; /** * @param root: param root: The root of the binary search tree * @param k1: An integer * @param k2: An integer * @return: return: Return all keys that k1&lt;=key&lt;=k2 in ascending order */ ArrayList&lt;Integer&gt; ans=new ArrayList&lt;&gt;();//递归中的变量声明需要注意 public ArrayList&lt;Integer&gt; searchRange(TreeNode root, int k1, int k2) &#123; if(null==root) return ans; if(root.val&gt;=k1&amp;&amp;root.val&lt;=k2) &#123; ans.add(root.val); searchRange(root.left,k1,k2); searchRange(root.right,k1,k2); &#125; else if(root.val&lt;k1) &#123; searchRange(root.right,k1,k2); &#125; else &#123; searchRange(root.left,k1,k2); &#125; Collections.sort(ans);//排序方法 return ans;&#125;&#125;","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"HashMap和LinkedHashMap的比较","slug":"HashMap和LinkedHashMap","date":"2017-12-16T14:12:32.000Z","updated":"2018-08-07T16:42:15.501Z","comments":true,"path":"2017/12/16/HashMap和LinkedHashMap/","link":"","permalink":"http://www.congboss.top/2017/12/16/HashMap和LinkedHashMap/","excerpt":"照例，举个栗子：","text":"照例，举个栗子：Demo:123456789101112131415161718192021222324252627282930313233import java.util.HashMap;import java.util.Iterator;import java.util.LinkedHashMap;import java.util.Map;public class TestLinkedHashMap &#123; public static void main(String args[]) &#123; System.out.println(\"*************************LinkedHashMap*************\"); Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;Integer,String&gt;(); map.put(6, \"apple\"); map.put(3, \"banana\"); map.put(2,\"pear\"); for (Iterator it = map.keySet().iterator();it.hasNext();) &#123; Object key = it.next(); System.out.println( key+\"=\"+ map.get(key)); &#125; System.out.println(\"*************************HashMap*************\"); Map&lt;Integer,String&gt; map1 = new HashMap&lt;Integer,String&gt;(); map1.put(6, \"apple\"); map1.put(3, \"banana\"); map1.put(2,\"pear\"); for (Iterator it = map1.keySet().iterator();it.hasNext();) &#123; Object key = it.next(); System.out.println( key+\"=\"+ map1.get(key)); &#125; &#125;&#125; 运行结果：*LinkedHashMap*1236=apple3=banana2=pear *HashMap**1232=pear6=apple3=banana 分析:LinkedHashmap 的特点是put进去的对象位置未发生变化,而HashMap会发生变化. 科普：java为数据结构中的映射定义了一个接口java.util.Map;它有四个实现类,分别是HashMap Hashtable LinkedHashMap 和TreeMap. Map主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。Hashmap 是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。 Hashtable与 HashMap类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。 LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。 TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。 一般情况下，我们用的最多的是HashMap,在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列. HashMap是一个最常用的Map，它根据键的hashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为NULL，允许多条记录的值为NULL。 HashMap不支持线程同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致性。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。 Hashtable与HashMap类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtable在写入时会比较慢。 LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。 在遍历的时候会比HashMap慢TreeMap能够把它保存的记录根据键排序，默认是按升序排序，也可以指定排序的比较器。当用Iterator遍历TreeMap时，得到的记录是排过序的。","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://www.congboss.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.congboss.top/tags/Java/"}]},{"title":"Construct Binary Tree from Preorder and Inorder Traversal","slug":"Construct Binary Tree from Preorder and Inorder Traversal","date":"2017-12-15T14:20:42.000Z","updated":"2018-03-11T06:39:37.284Z","comments":true,"path":"2017/12/15/Construct Binary Tree from Preorder and Inorder Traversal/","link":"","permalink":"http://www.congboss.top/2017/12/15/Construct Binary Tree from Preorder and Inorder Traversal/","excerpt":"","text":"Given preorder and inorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; int n=preorder.length-1; if(preorder.length!=inorder.length) return null; return buildHelp(preorder,0,n,inorder,0,n); &#125; public TreeNode buildHelp(int [] preorder,int preLow,int preHigh,int [] inorder,int inLow,int inHigh) &#123; if(preLow&gt;preHigh||inLow&gt;inHigh) return null; TreeNode root=new TreeNode(preorder[preLow]); int inRoot=inLow; for(int i=0;i&lt;inorder.length;i++) &#123; if(inorder[i]==root.val) &#123; inRoot=i; break; &#125; &#125; int leftTreeLen=inRoot-inLow; root.left=buildHelp(preorder,preLow+1,preLow+leftTreeLen,inorder,inLow,inRoot-1); root.right=buildHelp(preorder,preLow+leftTreeLen+1,preHigh,inorder,inRoot+1,inHigh); return root; &#125;&#125;","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"Decode String","slug":"Decode String","date":"2017-12-11T14:20:42.000Z","updated":"2018-03-11T06:39:42.046Z","comments":true,"path":"2017/12/11/Decode String/","link":"","permalink":"http://www.congboss.top/2017/12/11/Decode String/","excerpt":"Description:Given an encoded string, return it’s decoded string.\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\nYou may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4].","text":"Description:Given an encoded string, return it’s decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4].Soultion:123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public String decodeString(String s) &#123; String res=\"\"; int idx=0; int n=s.length(); ArrayList&lt;String&gt; charSt=new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; countSt=new ArrayList&lt;&gt;(); while(idx&lt;n) &#123; if(Character.isDigit(s.charAt(idx))) &#123; int count=0; while(Character.isDigit(s.charAt(idx))) &#123; count=count*10+(s.charAt(idx)-'0'); idx++; &#125; countSt.add(count); &#125; else if(s.charAt(idx)=='[') &#123; charSt.add(res); res=\"\"; idx++; &#125; else if(s.charAt(idx)==']') &#123; StringBuilder sb=new StringBuilder(charSt.remove(charSt.size()-1)); int times=countSt.remove(countSt.size()-1); for(int i=0;i&lt;times;i++) &#123; sb.append(res); &#125; res=sb.toString(); idx++; &#125; else &#123; res+=s.charAt(idx); idx++; &#125; &#125; return res; &#125;&#125; 晚安~","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"Maximum Product Subarray","slug":"Maximum Product Subarray","date":"2017-12-08T03:00:42.000Z","updated":"2018-03-08T13:56:52.120Z","comments":true,"path":"2017/12/08/Maximum Product Subarray/","link":"","permalink":"http://www.congboss.top/2017/12/08/Maximum Product Subarray/","excerpt":"题目：Find the contiguous subarray within an array (containing at least one number) which has the largest product.","text":"题目：Find the contiguous subarray within an array (containing at least one number) which has the largest product.一.暴力破解12345678910111213141516171819202122class Solution &#123; public int maxProduct(int[] nums) &#123; int n=nums.length; int ans=-2147483648; for(int i=0;i&lt;n;i++) &#123; for(int last=i;last&lt;n;last++) &#123; int product=1; for(int j=i;j&lt;=last;j++) &#123; product*=nums[j]; if(product&gt;ans) &#123; ans=product; &#125; &#125; &#125; &#125; return ans; &#125;&#125; 二、优化枚举12345678910111213141516171819class Solution &#123; public int maxProduct(int[] nums) &#123; int n=nums.length; int ans=-2147483648; for(int i=0;i&lt;n;i++) &#123; int product=1; for(int last=i;last&lt;n;last++) &#123; product*=nums[last]; if(product&gt;ans) &#123; ans=product; &#125; &#125; &#125; return ans; &#125;&#125; 三、时间复杂度为O(n)12345678910111213141516171819class Solution &#123; public int maxProduct(int[] nums) &#123; int maxProduct=nums[0]; int minProduct=nums[0]; int Product=nums[0]; int n=nums.length; for(int i=1;i&lt;n;i++) &#123; int temp=maxProduct; maxProduct=Math.max(Math.max(maxProduct*nums[i],minProduct*nums[i]),nums[i]); minProduct=Math.min(Math.min(temp*nums[i],minProduct*nums[i]),nums[i]); if(maxProduct&gt;Product) &#123; Product=maxProduct; &#125; &#125; return Product; &#125;&#125;","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"Reverse Linked List","slug":"Reverse Linked List","date":"2017-12-08T03:00:42.000Z","updated":"2018-03-24T02:12:50.977Z","comments":true,"path":"2017/12/08/Reverse Linked List/","link":"","permalink":"http://www.congboss.top/2017/12/08/Reverse Linked List/","excerpt":"","text":"Reverse a singly linked list.1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head==null||head.next==null) return head; LinkedList&lt;ListNode&gt; temp=new LinkedList&lt;&gt;(); while(head!=null) &#123; temp.add(head); head=head.next; &#125; ListNode tempNode=temp.remove(temp.size()-1); ListNode resultNode=tempNode; while(!temp.isEmpty()) &#123; tempNode.next=temp.remove(temp.size()-1); tempNode=tempNode.next; &#125; tempNode.next=null; return resultNode; &#125;&#125; 12345678910111213141516171819202122public class Solution &#123; /** * @param head: n * @return: The new head of reversed linked list. */ public ListNode reverse(ListNode head) &#123; // write your code here if(head==null||head.next==null) return head; ListNode cur=head.next; head.next=null; while(cur!=null) &#123; ListNode temp=cur.next; cur.next=head; head=cur; cur=temp; &#125; return head; &#125;&#125;","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"Lowest Common Ancestor of a Binary Tree","slug":"Lowest Common Ancestor of a Binary Tree","date":"2017-12-07T03:00:42.000Z","updated":"2018-03-11T05:39:48.127Z","comments":true,"path":"2017/12/07/Lowest Common Ancestor of a Binary Tree/","link":"","permalink":"http://www.congboss.top/2017/12/07/Lowest Common Ancestor of a Binary Tree/","excerpt":"","text":"Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if((root==null)||(root==p||root==q)) return root; TreeNode left=lowestCommonAncestor(root.left,p,q); TreeNode right=lowestCommonAncestor(root.right,p,q); if((left!=null)&amp;&amp;(right!=null)) return root; else &#123; return left==null?right:left; &#125; &#125;&#125; 思路：两个节点必然位于公共结点的左右两边。采用递归。","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"Longest Consecutive Sequence","slug":"Longest Consecutive Sequence","date":"2017-12-06T03:00:42.000Z","updated":"2018-03-09T09:49:45.433Z","comments":true,"path":"2017/12/06/Longest Consecutive Sequence/","link":"","permalink":"http://www.congboss.top/2017/12/06/Longest Consecutive Sequence/","excerpt":"","text":"Given an unsorted array of integers, find the length of the longest consecutive elements sequence. 12345678910111213141516171819202122class Solution &#123; public int longestConsecutive(int[] nums) &#123; HashMap&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;(); int res=0; for(int n:nums) &#123; if(!map.containsKey(n)) &#123; int left=map.containsKey(n-1)? map.get(n-1): 0; int right=map.containsKey(n+1)? map.get(n+1): 0; int sum=left+right+1; map.put(n,sum); res=Math.max(res,sum); map.put(n-left,sum); map.put(n+right,sum); &#125; &#125; return res; &#125;&#125; 思路：1.我们这边需要保证连续的数字无论是哪一个，map取值都是连续的个数。2.遇到相同的数字不予处理。","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"二叉树遍历（由子节点往父节点遍历）","slug":"二叉树遍历（由子节点往父节点遍历）","date":"2017-12-06T03:00:42.000Z","updated":"2018-03-12T07:10:30.434Z","comments":true,"path":"2017/12/06/二叉树遍历（由子节点往父节点遍历）/","link":"","permalink":"http://www.congboss.top/2017/12/06/二叉树遍历（由子节点往父节点遍历）/","excerpt":"","text":"Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; wrapList=new LinkedList&lt;List&lt;Integer&gt;&gt;(); if(root==null) return wrapList; Queue&lt;TreeNode&gt; queue=new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while(!queue.isEmpty()) &#123; int levelNum=queue.size(); List&lt;Integer&gt; subList=new LinkedList&lt;Integer&gt;(); for(int i=0;i&lt;levelNum;i++) &#123; if(queue.peek().left!=null) queue.offer(queue.peek().left); if(queue.peek().right!=null) queue.offer(queue.peek().right); subList.add(queue.poll().val); &#125; wrapList.add(0,subList); &#125; return wrapList; &#125;&#125;","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"Min Stack","slug":"Min Stack","date":"2017-12-05T03:00:42.000Z","updated":"2018-03-09T07:58:49.278Z","comments":true,"path":"2017/12/05/Min Stack/","link":"","permalink":"http://www.congboss.top/2017/12/05/Min Stack/","excerpt":"","text":"Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack.pop() – Removes the element on top of the stack.top() – Get the top element.getMin() – Retrieve the minimum element in the stack.1234567891011121314151617181920212223242526272829303132class MinStack &#123;private ArrayList&lt;Integer&gt; st=new ArrayList&lt;&gt;(); private ArrayList&lt;Integer&gt; minst=new ArrayList&lt;&gt;(); public void push(int x) &#123; st.add(x); if(minst.isEmpty()||minst.get(minst.size()-1)&gt;=x) minst.add(x); &#125; public void pop() &#123; if(st.isEmpty()) return; int element=st.remove(st.size()-1); if(!minst.isEmpty()&amp;&amp; element==minst.get(minst.size()-1)) &#123; minst.remove(minst.size()-1); &#125; &#125; public int top() &#123; if(!st.isEmpty()) return st.get(st.size()-1); return 0; &#125; public int getMin() &#123; if(!minst.isEmpty()) return minst.get(minst.size()-1); return 0; &#125;&#125;","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"Maximum Subarray","slug":"Maximum Subarray","date":"2017-12-04T03:00:42.000Z","updated":"2018-03-06T10:37:59.941Z","comments":true,"path":"2017/12/04/Maximum Subarray/","link":"","permalink":"http://www.congboss.top/2017/12/04/Maximum Subarray/","excerpt":"给定数组a[1…n]，求最大子数组和，即找出1&lt;=i&lt;=j&lt;=n，使a[i]+a[i+1]+…+a[j]最大。","text":"给定数组a[1…n]，求最大子数组和，即找出1&lt;=i&lt;=j&lt;=n，使a[i]+a[i+1]+…+a[j]最大。1.暴力破解12345678910111213141516171819202122class Solution &#123; public int maxSubArray(int[] nums) &#123; int n=nums.length; int ans=-2147483648; for(int i=0;i&lt;n;i++) &#123; for(int j=i+1;j&lt;n;j++) &#123; int sum=0; for(int s=i;s&lt;=j;s++) &#123; sum+=nums[s]; if(sum&gt;ans) &#123; ans=sum; &#125; &#125; &#125; &#125; return ans; &#125;&#125; 时间复杂度:O(n^3)附加空间复杂度：O(1)2.优化枚举TIPS：优化代码时，一般会去寻找最内层的循环，因为最内层的循环被执行的次数最多。123456789101112131415161718class Solution &#123; public int maxSubArray(int[] nums) &#123; int n=nums.length; int ans=-2147483648; for(int i=0;i&lt;n;i++) &#123; int sum=0; for(int j=i+1;j&lt;=n;j++) &#123;sum+=nums[j-1];if(sum&gt;ans) ans=sum; &#125; &#125; return ans;&#125;&#125; 时间复杂度O(n^2),附加空间复杂度O(1). 3.贪心算法12345678910111213141516171819202122class Solution &#123; public int maxSubArray(int[] nums) &#123; int n=nums.length; int ans=-2147483648; int sj=0; int minsi=0; int si=0; for(int i=0;i&lt;n;i++) &#123; sj+=nums[i]; if(minsi&gt;si) minsi=si; if(sj-minsi&gt;ans) &#123; ans=sj-minsi; &#125; si+=nums[i]; &#125; return ans;&#125;&#125; 2.1234567891011121314class Soultion&#123; public int maxSubArray(int[] nums) &#123;int n=nums.length;int sum=0;int ans=nums[0];for(i=0;i&lt;n;i++)&#123;sum+=nums[i];ans=max(ans,sum);if(sum&lt;0)sum=0&#125;｝return ans;&#125; 时间复杂度：O(n),附加空间复杂度：O(1) 解题思路：加法转换为减法，设S[j]=a[0]+...+a[j];则Max[i,j]=S[j]-minS[i];从而降低时空复杂度，减少冗余。算法嘛，最重要的就是对于时间复杂度和空间复杂度的优化。 小技巧：优化代码时，一般会去寻找最内层的循环，因为最内层的循环被执行的次数最多。","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.congboss.top/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.congboss.top/tags/算法/"}]},{"title":"Arduino+温度传感器+Android 实现冷链温度实时获取","slug":"Arduino+温度传感器+Android实现冷链温度实时获取","date":"2017-07-17T15:00:42.000Z","updated":"2019-05-12T11:24:42.180Z","comments":true,"path":"2017/07/17/Arduino+温度传感器+Android实现冷链温度实时获取/","link":"","permalink":"http://www.congboss.top/2017/07/17/Arduino+温度传感器+Android实现冷链温度实时获取/","excerpt":"在学校参与的IOT项目中需要实现对于冷链物流车辆内部温度的实时获取和上传。\n  起初想通过采购第三方物联网平台（乐联网etc）的集成硬件实现之类的功能，但是存在数据无法及时查询和自主获取的问题，所以还是决定自己搞。经过讨论决定采取Arduino+温度传感器+Android的方式，Android通过OTG线连接Arduino,作为USB HOST模式，获取到温度传感器传来的数据，并且网络编程上传到服务器，从而可以进行预警回溯之类的操作。  下面对这个功能的实现做一个阐述：","text":"在学校参与的IOT项目中需要实现对于冷链物流车辆内部温度的实时获取和上传。 起初想通过采购第三方物联网平台（乐联网etc）的集成硬件实现之类的功能，但是存在数据无法及时查询和自主获取的问题，所以还是决定自己搞。经过讨论决定采取Arduino+温度传感器+Android的方式，Android通过OTG线连接Arduino,作为USB HOST模式，获取到温度传感器传来的数据，并且网络编程上传到服务器，从而可以进行预警回溯之类的操作。 下面对这个功能的实现做一个阐述： 1.Arduino端连接温度传感器获取温度这里功能实现并不复杂，设置一些必要参数，通过公式获取温度信息并且输出就可以了。贴上温度获取实现代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556int temp;unsigned int loopCnt;int chr[40] = &#123;0&#125;;unsigned long time;#define pin 4void setup()&#123; Serial.begin(9600);&#125;void loop()&#123; bgn: delay(2000); pinMode(pin,OUTPUT); digitalWrite(pin,LOW); delay(20); digitalWrite(pin,HIGH); delayMicroseconds(40); digitalWrite(pin,LOW); pinMode(pin,INPUT); loopCnt=10000; while(digitalRead(pin) != HIGH) &#123; if(loopCnt-- == 0) &#123; Serial.println(\"HIGH\"); goto bgn; &#125; &#125; loopCnt=30000; while(digitalRead(pin) != LOW) &#123; if(loopCnt-- == 0) &#123; Serial.println(\"LOW\"); goto bgn; &#125; &#125; for(int i=0;i&lt;40;i++) &#123; while(digitalRead(pin) == LOW) &#123;&#125; time = micros(); while(digitalRead(pin) == HIGH) &#123;&#125; if (micros() - time &gt;50) &#123; chr[i]=1; &#125;else&#123; chr[i]=0; &#125; &#125;temp=chr[16]*128+chr[17]*64+chr[18]*32+chr[19]*16+chr[20]*8+chr[21]*4+chr[22]*2+chr[23]; Serial.print(\"temp:\"); Serial.println(temp);&#125; 2.Android获取Arduino发送来的数据 我采取的是使用OTG连接Android和Arduino开发板来收发数据：USB OTG：USB On-The-Go通常缩写为USB OTG，是USB2.0规格的补充标准。它可使USB设备，例如播放器或手机，从USB周边设备变为USB主机，与其他USB设备连接通信。在正常情况下，这些支持OTG的USB设备和USB主机（如台式机或者手提电脑），仍然作为USB周边设备使用。 这段话是wiki对USB OTG的说明。 也就是说Android端作为USB HOST设备，而Arduino则是作为周边其他USB设备。而对于USB HOST的一些操作和描述，就不再赘述，附上官方文档：https://developer.android.com/guide/topics/connectivity/usb/host.html 在Android中建立一个串口连接确实比较麻烦，冗余代码很多，所幸在Github上找到一个比较好的一直在更新的库文件：https://github.com/felHR85/UsbSerial/，对一些操作做了很好的封装。在Android studio中导入这个第三方库之后。对串口做一些设置：123456789101112131415161718192021222324252627282930if (serialPort != null) &#123; if (serialPort.open()) &#123; //Set Serial Connection Parameters. setUiEnabled(true); serialPort.setBaudRate(9600); serialPort.setDataBits(UsbSerialInterface.DATA_BITS_8); serialPort.setStopBits(UsbSerialInterface.STOP_BITS_1); serialPort.setParity(UsbSerialInterface.PARITY_NONE); serialPort.setFlowControl(UsbSerialInterface.FLOW_CONTROL_OFF); serialPort.read(mCallback);对设备进行判定：HashMap&lt;String, UsbDevice&gt; usbDevices = usbManager.getDeviceList(); if (!usbDevices.isEmpty()) &#123; boolean keep = true; for (Map.Entry&lt;String, UsbDevice&gt; entry : usbDevices.entrySet()) &#123; device = entry.getValue(); int deviceVID = device.getVendorId(); if (deviceVID == 0x2341)//Arduino Vendor ID &#123; PendingIntent pi = PendingIntent.getBroadcast(this, 0, new Intent(ACTION_USB_PERMISSION), 0); usbManager.requestPermission(device, pi); keep = false; &#125; else &#123; connection = null; device = null; &#125; if (!keep) break; &#125; &#125; 关于数据的上传则不是难点，可以采取socket之类的办法。","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://www.congboss.top/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.congboss.top/tags/Android/"},{"name":"Arduino","slug":"Arduino","permalink":"http://www.congboss.top/tags/Arduino/"},{"name":"USB HOST","slug":"USB-HOST","permalink":"http://www.congboss.top/tags/USB-HOST/"}]},{"title":"Git笔记","slug":"Git笔记","date":"2017-07-04T03:00:42.000Z","updated":"2019-05-12T13:58:23.711Z","comments":true,"path":"2017/07/04/Git笔记/","link":"","permalink":"http://www.congboss.top/2017/07/04/Git笔记/","excerpt":"  Git,是一个分布式版本控制系统。初始化一个Git仓库：1git init\n添加文件到Git仓库，分两步：第一步:1git add &lt;file&gt;\n，注意，可反复多次使用，添加多个文件；添加所有文件：1git add .\n第二步:1git commit -m&quot;注释内容&quot;\n，完成。\n查看工作区状态：1git status\n查看修改内容：1git diff &lt;file&gt;\n版本回退：查看提交记录：1git log\n如果只想显示一行信息：1git log --pretty=oneline\nGit中的当前版本用HEAD表示，同理，上一个版本就是HEAD^,上上一个版本就是HEAD^^，上100个版本就是HEAD~100.\n回退上一个版本：1git reset --hard HEAD^\n查看命令历史记录：1git reflog\n工作区和缓存区工作区就是电脑中能看到的目录。","text":"Git,是一个分布式版本控制系统。初始化一个Git仓库：1git init 添加文件到Git仓库，分两步：第一步:1git add &lt;file&gt; ，注意，可反复多次使用，添加多个文件；添加所有文件：1git add . 第二步:1git commit -m&quot;注释内容&quot; ，完成。 查看工作区状态：1git status 查看修改内容：1git diff &lt;file&gt; 版本回退：查看提交记录：1git log 如果只想显示一行信息：1git log --pretty=oneline Git中的当前版本用HEAD表示，同理，上一个版本就是HEAD^,上上一个版本就是HEAD^^，上100个版本就是HEAD~100. 回退上一个版本：1git reset --hard HEAD^ 查看命令历史记录：1git reflog 工作区和缓存区工作区就是电脑中能看到的目录。 版本库即影藏目录.git，不算版本工作区，而是Git的版本库。Git中存在名为stage（index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD. 将文件像Git版本库里添加的时候，分两步执行：1git add ，将文件添加到缓存区。1git commit ，将文件从缓存区添加到当前分支。简单理解就是将需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 每一次修改，如果不add到暂存区，那就不会加入到commit中。 撤销修改：如果在工作区进行修改后尚未提交到暂存区。使用命令：1git checkout --file 来丢弃工作区的修改 如果已经add到暂存区了，但是还没有commit的话可以使用：12git reset HEAD file:将暂存区的修改撤销掉，重新放回工作区。git reset:既可以回退版本，也可以把暂存区的修改回退到工作区。 如果不仅添加到缓存区，而且还commit了，那就使用版本回退，当然前提是没有推送到远程库。 删除文件：一般情况在我们在文件管理器中将一个文件删除或者使用命令：1rm file 将文件删除后，工作区与版本库将会不一致，如果确实要将文件删除，使用命令：1git rm file ,并且1git commit . 如果是误删的操作，那么可以使用命令：1git checkout -- file 1git checkout 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 但是只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 使用远程仓库：关联远程仓库：1git remote add origin git@github.com:&lt;username&gt;/&lt;file&gt;.git 将本地仓库推送到远程库上：1git push -u origin master 实际上是将master分支推送到远程仓库上，-u是将本地仓库和远程仓库关联起来了。之后操作的话只需：1git push origin master 命令即可。1git push origin &lt;本地分支名字&gt;:&lt;远程分支名字&gt; 克隆远程仓库：使用命令：1git clone git@github.com:&lt;username&gt;/&lt;file&gt;.git 分支： 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： Git创建一个分支很快，因为除了增加一个dev指针外，更改HEAD的指向，没有别的任何变化。不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：合并完分支后，可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，就剩下了一条master分支：查看分支：1git branch 创建分支：1git branch &lt;name&gt; 切换分支：1git checkout &lt;name&gt; 创建+切换分支：1git checkout -b &lt;name&gt; 合并某分支到当前分支：1git merge &lt;name&gt; 删除分支：1git branch -d &lt;name&gt; 解决冲突：假设再建立一个新的分支feature1，然后master分支和feature1分支都有提交，Git将无法实行合并。需要手动修改解决冲突，再合并。查看分支合并图：1git log --graph 分支管理：合并分支时，如果可以，一般选择fast forward的方式，但是这样再删除分支后，将丢失分支信息。可以强制禁用ff方式，Git将再merge时形成一个新的commit，这样从分支历史上就可以看出分支信息。新建dev分支。准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward：1$ git merge --no-ff -m &quot;merge with no-ff&quot; dev 不使用ff模式，merge后就是这样：正常工作情况： bug分支：修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场1git stash 一下，然后去修复bug，修复后，再1git stash pop ，回到工作现场。 feature分支：开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过1git branch -D &lt;name&gt; 强行删除。 多人协作：当从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了。并且，远程仓库的默认名称是origin。查看远程仓库的信息：1git remote 或者使用1git remote -v 查看更详细的信息。 推送分支：就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：1git push origin master 类似的，推送dev分支：1git push origin dev TIPs:master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了; feature分支是否推到远程，取决于是否合作在上面开发。 小结:查看远程库信息，使用1git remote -v ； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用1git push origin branch-name ，如果推送失败，先用1git pull 抓取远程的新提交； 在本地创建和远程分支对应的分支，使用1git checkout -b branch-name origin/branch-name ，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用1git branch --set-upstream branch-name origin/branch-name ； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 参考：https://www.liaoxuefeng.com/wiki/896043488029600","raw":null,"content":null,"categories":[{"name":"Git","slug":"Git","permalink":"http://www.congboss.top/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.congboss.top/tags/Git/"}]},{"title":"Hexo常用命令","slug":"Hexo常见命令","date":"2017-05-01T05:03:42.000Z","updated":"2019-05-12T11:56:05.464Z","comments":true,"path":"2017/05/01/Hexo常见命令/","link":"","permalink":"http://www.congboss.top/2017/05/01/Hexo常见命令/","excerpt":"","text":"#新建文章1hexo new &quot;postName&quot; #新建页面1hexo new page &quot;pageName&quot; #生成静态页面至public目录1hexo generate #开启预览访问窗口1hexo server #部署到Github1hexo deploy #查看帮助1hexo help #查看hexo的版本1hexo version 组合命令：1234hexo n ==hexo newhexo g ==hexo generatehexo s ==hexo serverhexo d ==hexo deploy #生成并本地预览1hexo s -g #生成并上传1hexo d -g","raw":null,"content":null,"categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.congboss.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.congboss.top/tags/Hexo/"}]},{"title":"Next主题添加本地搜索的配置","slug":"Next主题添加本地搜索的配置","date":"2017-04-11T02:20:42.000Z","updated":"2017-12-21T09:01:05.343Z","comments":true,"path":"2017/04/11/Next主题添加本地搜索的配置/","link":"","permalink":"http://www.congboss.top/2017/04/11/Next主题添加本地搜索的配置/","excerpt":"","text":"本站点采用Local Search，原理是通过安装1hexo-generator-search 插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。首先，安装1hexo-generator-search 在站点根目录下执行以下命令： 1npm install hexo-generator-search --save 再安装1hexo-generator-searchdb 即在站点的根目录下执行下列命令： 1npm install hexo-generator-searchdb --save 安装完成后，我们需要启用搜索。 编辑站点配置文件，新增以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000 最后将主题配置文件的local_search改成true。 即设置主题配置文件：12local_search: enable: true OK，这样本地搜索就可以成功添加了。","raw":null,"content":null,"categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.congboss.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.congboss.top/tags/Hexo/"},{"name":"Next","slug":"Next","permalink":"http://www.congboss.top/tags/Next/"}]},{"title":"静态常量与静态变量","slug":"静态变量与静态常量","date":"2016-05-02T14:02:23.000Z","updated":"2018-08-07T16:47:59.274Z","comments":true,"path":"2016/05/02/静态变量与静态常量/","link":"","permalink":"http://www.congboss.top/2016/05/02/静态变量与静态常量/","excerpt":"静态变量：1static String CC=\"congboss\";//类成员，属于类，不属于任何对象，类第一次加载时放入内存。","text":"静态变量：1static String CC=\"congboss\";//类成员，属于类，不属于任何对象，类第一次加载时放入内存。 例如：12345class Student｛private String userId;private static String googId=\"12\";｝ 每个对象都拥有自己的userId,但这个类的所有实例将共享一个goodId.有1000个对象就有1000个userId,但只有一个静态域goodId。即使没有新建对象，静态域goodId也存在。 静态常量：1private static final CC=\"Guest\"; 不用new对象就可以访问静态常量，但是静态常量是不可以修改的。 我举个栗子：我们常用的System.out。它在System类中的声明：1234public class System&#123; public static final PrintStream out = ...; &#125; 所以我们才不需要new一个System对象而直接访问out属性呀！ 晚安~","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://www.congboss.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.congboss.top/tags/Java/"}]}]}